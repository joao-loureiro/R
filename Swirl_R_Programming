########################
1. BASIC BUILDING BLOCKS
########################

|                                                    |   0%
| In this lesson, we will explore some basic building blocks
| of the R programming language.
...
|=                                                   |   3%
| If at any point you'd like more information on a particular
| topic related to R, you can type help.start() at the
| prompt, which will open a menu of resources (either within
| RStudio or your default web browser, depending on your
| setup). Alternatively, a simple web search often yields the
| answer you're looking for.
...
|===                                                 |   5%
| In its simplest form, R can be used as an interactive
| calculator. Type 5 + 7 and press Enter.
> 5+7
[1] 12
| All that practice is paying off!
|====                                                |   8%
| R simply prints the result of 12 by default. However, R is
| a programming language and often the reason we use a
| programming language as opposed to a calculator is to
| automate some process or avoid unnecessary repetition.
...
|=====                                               |  11%
| In this case, we may want to use our result from above in a
| second calculation. Instead of retyping 5 + 7 every time we
| need it, we can just create a new variable that stores the
| result.
...
|=======                                             |  13%
| The way you assign a value to a variable in R is by using
| the assignment operator, which is just a 'less than' symbol
| followed by a 'minus' sign. It looks like this: <-
...
|========                                            |  16%
| Think of the assignment operator as an arrow. You are
| assigning the value on the right side of the arrow to the
| variable name on the left side of the arrow.
...
|==========                                          |  18%
| To assign the result of 5 + 7 to a new variable called x,
| you type x <- 5 + 7. This can be read as 'x gets 5 plus 7'.
| Give it a try now.
> 5+7 -> x
| You're the best!
|===========                                         |  21%
| You'll notice that R did not print the result of 12 this
| time. When you use the assignment operator, R assumes that
| you don't want to see the result immediately, but rather
| that you intend to use the result for something else later
| on.
...x
|============                                        |  24%
| To view the contents of the variable x, just type x and
| press Enter. Try it now.
> x
[1] 12
| All that hard work is paying off!
|==============                                      |  26%
| Now, store the result of x - 3 in a new variable called y.
> y <- x - 3
| You got it!
|===============                                     |  29%
| What is the value of y? Type y to find out.
> y
[1] 9
| That's correct!
|================                                    |  32%
| Now, let's create a small collection of numbers called a
| vector. Any object that contains data is called a data
| structure and numeric vectors are the simplest type of data
| structure in R. In fact, even a single number is considered
| a vector of length one.
...
|==================                                  |  34%
| The easiest way to create a vector is with the c()
| function, which stands for 'concatenate' or 'combine'. To
| create a vector containing the numbers 1.1, 9, and 3.14,
| type c(1.1, 9, 3.14). Try it now and store the result in a
| variable called z.
> c(1.1,9,3.14)->z
| You are quite good my friend!
|===================                                 |  37%
| Anytime you have questions about a particular function, you
| can access R's built-in help files via the `?` command. For
| example, if you want more information on the c() function,
| type ?c without the parentheses that normally follow a
| function name. Give it a try.
> ?c
| You got it!
|=====================                               |  39%
| Type z to view its contents. Notice that there are no
| commas separating the values in the output.
> z
[1] 1.10 9.00 3.14
| You are amazing!
|======================                              |  42%
| You can combine vectors to make a new vector. Create a new
| vector that contains z, 555, then z again in that order.
| Don't assign this vector to a new variable, so that we can
| just see the result immediately.
> c(z, 555, z)
[1]   1.10   9.00   3.14 555.00   1.10   9.00   3.14
| You are amazing!
|=======================                             |  45%
| Numeric vectors can be used in arithmetic expressions. Type
| the following to see what happens: z * 2 + 100.
> z * 2 + 100
[1] 102.20 118.00 106.28
| You are really on a roll!
|=========================                           |  47%
| First, R multiplied each of the three elements in z by 2.
| Then it added 100 to each element to get the result you see
| above.
...
|==========================                          |  50%
| Other common arithmetic operators are `+`, `-`, `/`, and
| `^` (where x^2 means 'x squared'). To take the square root,
| use the sqrt() function and to take the absolute value, use
| the abs() function.
...
|===========================                         |  53%
| Take the square root of z - 1 and assign it to a new
| variable called my_sqrt.
old> my_sqrt <- sqrt(z-1)
| Nice work!
|=============================                       |  55%
| Before we view the contents of the my_sqrt variable, what
| do you think it contains?
1: a single number (i.e a vector of length 1)
2: a vector of length 0 (i.e. an empty vector)
3: a vector of length 3
Selection: 3
| All that practice is paying off!
|==============================                      |  58%
| Print the contents of my_sqrt.
> my_sqrt
[1] 0.3162278 2.8284271 1.4628739
| You are quite good my friend!
|===============================                     |  61%
| As you may have guessed, R first subtracted 1 from each
| element of z, then took the square root of each element.
| This leaves you with a vector of the same length as the
| original vector z.
...
|=================================                   |  63%
| Now, create a new variable called my_div that gets the
| value of z divided by my_sqrt.
> z / my_sqrt -> my_div
| Nice work!
|==================================                  |  66%
| Which statement do you think is true?
1: my_div is undefined
2: The first element of my_div is equal to the first element of z divided by the first element of my_sqrt, and so on...
3: my_div is a single number (i.e a vector of length 1)
Selection: 2
| Great job!
|====================================                |  68%
| Go ahead and print the contents of my_div.
> 
> my_div
[1] 3.478505 3.181981 2.146460
| That's a job well done!
|=====================================               |  71%
| When given two vectors of the same length, R simply
| performs the specified arithmetic operation (`+`, `-`, `*`,
| etc.) element-by-element. If the vectors are of different
| lengths, R 'recycles' the shorter vector until it is the
| same length as the longer vector.
...
|======================================              |  74%
| When we did z * 2 + 100 in our earlier example, z was a
| vector of length 3, but technically 2 and 100 are each
| vectors of length 1.
...
|========================================            |  76%
| Behind the scenes, R is 'recycling' the 2 to make a vector
| of 2s and the 100 to make a vector of 100s. In other words,
| when you ask R to compute z * 2 + 100, what it really
| computes is this: z * c(2, 2, 2) + c(100, 100, 100).
...
|=========================================           |  79%
| To see another example of how this vector 'recycling'
| works, try adding c(1, 2, 3, 4) and c(0, 10). Don't worry
| about saving the result in a new variable.
> c(1,2,3,4)+c(0,10)
[1]  1 12  3 14
| You are really on a roll!
|==========================================          |  82%
| If the length of the shorter vector does not divide evenly
| into the length of the longer vector, R will still apply
| the 'recycling' method, but will throw a warning to let you
| know something fishy might be going on.
...
|============================================        |  84%
| Try c(1, 2, 3, 4) + c(0, 10, 100) for an example.
> c(1,2,3,4)+c(0,10,100)
[1]   1  12 103   4
Warning message:
In c(1, 2, 3, 4) + c(0, 10, 100) :
  longer object length is not a multiple of shorter object length
| You are really on a roll!
|=============================================       |  87%
| Before concluding this lesson, I'd like to show you a
| couple of time-saving tricks.
...
|===============================================     |  89%
| Earlier in the lesson, you computed z * 2 + 100. Let's
| pretend that you made a mistake and that you meant to add
| 1000 instead of 100. You could either re-type the
| expression, or...
...
|================================================    |  92%
| In many programming environments, the up arrow will cycle
| through previous commands. Try hitting the up arrow on your
| keyboard until you get to this command (z * 2 + 100), then
| change 100 to 1000 and hit Enter. If the up arrow doesn't
| work for you, just type the corrected command.
> z * 2 + 1000
[1] 1002.20 1018.00 1006.28
| Great job!
|=================================================   |  95%
| Finally, let's pretend you'd like to view the contents of a
| variable that you created earlier, but you can't seem to
| remember if you named it my_div or myDiv. You could try
| both and see what works, or...
...
|=================================================== |  97%
| You can type the first two letters of the variable name,
| then hit the Tab key (possibly more than once). Most
| programming environments will provide a list of variables
| that you've created that begin with 'my'. This is called
| auto-completion and can be quite handy when you have many
| variables in your workspace. Give it a try. (If
| auto-completion doesn't work for you, just type my_div and
| press Enter.)
> my_div
[1] 3.478505 3.181981 2.146460
| Perseverance, that's the answer.
|====================================================| 100%

######################
2. WORKSPACE AND FILES
######################

|                                                    |   0%
| In this lesson, you'll learn how to examine your local
| workspace in R and begin to explore the relationship
| between your workspace and the file system of your machine.
...
|=                                                   |   3%
| Because different operating systems have different
| conventions with regards to things like file paths, the
| outputs of these commands may vary across machines.
...
|===                                                 |   5%
| However it's important to note that R provides a common API
| (a common set of commands) for interacting with files, that
| way your code will work across different kinds of
| computers.
...
|====                                                |   8%
| Let's jump right in so you can get a feel for how these
| special functions work!
...
|=====                                               |  10%
| Determine which directory your R session is using as its
| current working directory using getwd().
> getwd()
[1] "C:/Users/Joao.Loureiro/Documents"
| Keep up the great work!
|=======                                             |  13%
| List all the objects in your local workspace using ls().
> ls()
[1] "my_div"  "my_sqrt" "x"       "y"       "z"      
| Keep up the great work!
|========                                            |  15%
| Some R commands are the same as their equivalents commands
| on Linux or on a Mac. Both Linux and Mac operating systems
| are based on an operating system called Unix. It's always a
| good idea to learn more about Unix!
...
|=========                                           |  18%
| Assign 9 to x using x <- 9.
> x <- 9
| You are quite good my friend!
|===========                                         |  21%
| Now take a look at objects that are in your workspace using
| ls().
> ls()
[1] "my_div"  "my_sqrt" "x"       "y"       "z"      
| Great job!
|============                                        |  23%
| List all the files in your working directory using
| list.files() or dir().
> dir()
 [1] "Custom Office Templates"                      
 [2] "data.dat"                                     
 [3] "data.txt"                                     
 [4] "Database1.accdb"                              
 [5] "Database2.accdb"                              
 [6] "dataedit.dat"                                 
 [7] "Default.rdp"                                  
 [8] "desktop.ini"                                  
 [9] "Estado da BD.dqy"                             
[10] "Estado da BD.xlsm"                            
[11] "Graphics"                                     
[12] "Links Server & Clients"                       
[13] "My Data Sources"                              
[14] "My Music"                                     
[15] "My Pictures"                                  
[16] "My Received Files"                            
[17] "My Videos"                                    
[18] "OneNote Notebooks"                            
[19] "Outlook Files"                                
[20] "PERSONAL.XLSB"                                
[21] "PV Event Log2 (Verificar Failures) - Copy.dqy"
[22] "SQL Server Management Studio"                 
[23] "Visual Studio 2010"                           
[24] "Visual Studio 2017"                           
[25] "WinMerge"                                     
| Great job!
|=============                                       |  26%
| As we go through this lesson, you should be examining the
| help page for each new function. Check out the help page
| for list.files with the command ?list.files.
> ?list.files
| Nice work!
|===============                                     |  28%
| One of the most helpful parts of any R help file is the See
| Also section. Read that section for list.files. Some of
| these functions may be used in later portions of this
| lesson.
...
|================                                    |  31%
| Using the args() function on a function name is also a
| handy way to see what arguments a function can take.
...
|=================                                   |  33%
| Use the args() function to determine the arguments to
| list.files().
| Type args(list.files) to see the arguments to list.files.
> args(list.files)
function (path = ".", pattern = NULL, all.files = FALSE, full.names = FALSE, 
    recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, 
    no.. = FALSE) 
NULL
| You got it!
|===================                                 |  36%
| Assign the value of the current working directory to a
| variable called "old.dir".
> old.dir <- getwd()
| Your dedication is inspiring!
|====================                                |  38%
| We will use old.dir at the end of this lesson to move back
| to the place that we started. A lot of query functions like
| getwd() have the useful property that they return the
| answer to the question as a result of the function.
...
|=====================                               |  41%
| Use dir.create() to create a directory in the current
| working directory called "testdir".
> dir.create("testdir")
| That's a job well done!
|=======================                             |  44%
| We will do all our work in this new directory and then
| delete it after we are done. This is the R analog to "Take
| only pictures, leave only footprints."
...
|========================                            |  46%
| Set your working directory to "testdir" with the setwd()
| command.
> setwd("testdir")
| Keep up the great work!
|=========================                           |  49%
| In general, you will want your working directory to be
| someplace sensible, perhaps created for the specific
| project that you are working on. In fact, organizing your
| work in R packages using RStudio is an excellent option.
| Check out RStudio at http://www.rstudio.com/
...
|===========================                         |  51%
| Create a file in your working directory called "mytest.R"
| using the file.create() function.
> file.create("mytest.R")
[1] TRUE
| Nice work!
|============================                        |  54%
| This should be the only file in this newly created
| directory. Let's check this by listing all the files in the
| current directory.
> list.files()
[1] "mytest.R"
| All that hard work is paying off!
|=============================                       |  56%
| Check to see if "mytest.R" exists in the working directory
| using the file.exists() function.
> file.exists("mytest.R")
[1] TRUE
| You're the best!
|===============================                     |  59%
| These sorts of functions are excessive for interactive use.
| But, if you are running a program that loops through a
| series of files and does some processing on each one, you
| will want to check to see that each exists before you try
| to process it.
...
|================================                    |  62%
| Access information about the file "mytest.R" by using
| file.info().
> file.info("mytest.R")
         size isdir mode               mtime
mytest.R    0 FALSE  666 2017-09-13 17:24:47
                       ctime               atime exe
mytest.R 2017-09-13 17:24:47 2017-09-13 17:24:47  no
| You are really on a roll!
|=================================                   |  64%
| You can use the $ operator --- e.g.,
| file.info("mytest.R")$mode --- to grab specific items.
...file.info("mytest.r")$mode
|===================================                 |  67%
| Change the name of the file "mytest.R" to "mytest2.R" by
| using file.rename().
> file.rename("mytest.R", "mytest2.R")
[1] TRUE
| That's correct!
|====================================                |  69%
| Your operating system will provide simpler tools for these
| sorts of tasks, but having the ability to manipulate files
| programatically is useful. You might now try to delete
| mytest.R using file.remove('mytest.R'), but that won't work
| since mytest.R no longer exists. You have already renamed
| it.
...
|=====================================               |  72%
| Make a copy of "mytest2.R" called "mytest3.R" using
| file.copy().
> file.copy ("mytest2.R", "mytest3.R")
[1] TRUE
| Excellent job!
|=======================================             |  74%
| You now have two files in the current directory. That may
| not seem very interesting. But what if you were working
| with dozens, or millions, of individual files? In that
| case, being able to programatically act on many files would
| be absolutely necessary. Don't forget that you can,
| temporarily, leave the lesson by typing play() and then
| return by typing nxt().
...
|========================================            |  77%
| Provide the relative path to the file "mytest3.R" by using
| file.path().
> file.path("mytest3.R")
[1] "mytest3.R"
| All that hard work is paying off!
|=========================================           |  79%
| You can use file.path to construct file and directory paths
| that are independent of the operating system your R code is
| running on. Pass 'folder1' and 'folder2' as arguments to
| file.path to make a platform-independent pathname.
> file.path("folder1", "folder2")
[1] "folder1/folder2"
| That's correct!
|===========================================         |  82%
| Take a look at the documentation for dir.create by entering
| ?dir.create . Notice the 'recursive' argument. In order to
| create nested directories, 'recursive' must be set to TRUE.
> ?dir.create
| Excellent work!
|============================================        |  85%
| Create a directory in the current working directory called
| "testdir2" and a subdirectory for it called "testdir3", all
| in one command by using dir.create() and file.path().
> dir.create("testdir2")
| That's not the answer I was looking for, but try again. Or, type
| info() for more options.
| dir.create(file.path('testdir2', 'testdir3'), recursive = TRUE) will
| do the trick. If you forgot the recursive argument, the command may
| have appeared to work, but it didn't create the nested directory.
> dir.create(file.path("testdir2", "testdir3"), recursive = TRUE)
| You are amazing!
|=============================================       |  87%
| Go back to your original working directory using setwd(). (Recall
| that we created the variable old.dir with the full path for the
| orginal working directory at the start of these questions.)
> setwd(old.dir)
| You nailed it! Good job!
|===============================================     |  90%
| It is often helpful to save the settings that you had before you
| began an analysis and then go back to them at the end. This trick is
| often used within functions; you save, say, the par() settings that
| you started with, mess around a bunch, and then set them back to the
| original values at the end. This isn't the same as what we have done
| here, but it seems similar enough to mention.
...
|================================================    |  92%
| After you finish this lesson delete the 'testdir' directory that you
| just left (and everything in it)
...dir()
|=================================================   |  95%
| Take nothing but results. Leave nothing but assumptions. That sounds
| like 'Take nothing but pictures. Leave nothing but footprints.' But
| it makes no sense! Surely our readers can come up with a better motto
| . . .
...getwd()
|=================================================== |  97%
| In this lesson, you learned how to examine your R workspace and work
| with the file system of your machine from within R. Thanks for
| playing!
...
|====================================================| 100%

####################
SEQUENCES OF NUMBERS
####################

|                                                              |   0%
| In this lesson, you'll learn how to create sequences of numbers in R.
...
|===                                                           |   4%
| The simplest way to create a sequence of numbers in R is by using the
| `:` operator. Type 1:20 to see how it works.
> 1:20
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
| Great job!
|=====                                                         |   9%
| That gave us every integer between (and including) 1 and 20. We could
| also use it to create a sequence of real numbers. For example, try
| pi:10.
> pi:10
[1] 3.141593 4.141593 5.141593 6.141593 7.141593 8.141593 9.141593
| You're the best!
|========                                                      |  13%
| The result is a vector of real numbers starting with pi (3.142...)
| and increasing in increments of 1. The upper limit of 10 is never
| reached, since the next number in our sequence would be greater than
| 10.
...
|===========                                                   |  17%
| What happens if we do 15:1? Give it a try to find out.
> 15:1
 [1] 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1
| That's correct!
|=============                                                 |  22%
| It counted backwards in increments of 1! It's unlikely we'd want this
| behavior, but nonetheless it's good to know how it could happen.
...
|================                                              |  26%
| Remember that if you have questions about a particular R function,
| you can access its documentation with a question mark followed by the
| function name: ?function_name_here. However, in the case of an
| operator like the colon used above, you must enclose the symbol in
| backticks like this: ?`:`. (NOTE: The backtick (`) key is generally
| located in the top left corner of a keyboard, above the Tab key. If
| you don't have a backtick key, you can use regular quotes.)
...
|===================                                           |  30%
| Pull up the documentation for `:` now.
> ?`:`
| Nice work!
|======================                                        |  35%
| Often, we'll desire more control over a sequence we're creating than
| what the `:` operator gives us. The seq() function serves this
| purpose.
...
|========================                                      |  39%
| The most basic use of seq() does exactly the same thing as the `:`
| operator. Try seq(1, 20) to see this.
> seq(1, 20)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
| You got it right!
|===========================                                   |  43%
| This gives us the same output as 1:20. However, let's say that
| instead we want a vector of numbers ranging from 0 to 10, incremented
| by 0.5. seq(0, 10, by=0.5) does just that. Try it out.
> seq(0,10,by=0.5)
 [1]  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0
[14]  6.5  7.0  7.5  8.0  8.5  9.0  9.5 10.0
| You're the best!
|==============================                                |  48%
| Or maybe we don't care what the increment is and we just want a
| sequence of 30 numbers between 5 and 10. seq(5, 10, length=30) does
| the trick. Give it a shot now and store the result in a new variable
| called my_seq.
> my_seq <- seq(5,10,length=30)
| You are really on a roll!
|================================                              |  52%
| To confirm that my_seq has length 30, we can use the length()
| function. Try it now.
> length(my_seq)
[1] 30
| Perseverance, that's the answer.
|===================================                           |  57%
| Let's pretend we don't know the length of my_seq, but we want to
| generate a sequence of integers from 1 to N, where N represents the
| length of the my_seq vector. In other words, we want a new vector (1,
| 2, 3, ...) that is the same length as my_seq.
...
|======================================                        |  61%
| There are several ways we could do this. One possibility is to
| combine the `:` operator and the length() function like this:
| 1:length(my_seq). Give that a try.
> 1:length(my_seq)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22
[23] 23 24 25 26 27 28 29 30
| You are quite good my friend!
|========================================                      |  65%
| Another option is to use seq(along.with = my_seq). Give that a try.
> play()
| Entering play mode. Experiment as you please, then type nxt() when
| you are ready to resume the lesson.
> seq(1,length(my_seq))
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22
[23] 23 24 25 26 27 28 29 30
> nxt()
| Resuming lesson...
| Another option is to use seq(along.with = my_seq). Give that a try.
> seq(along.with = my_seq)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22
[23] 23 24 25 26 27 28 29 30
| You are really on a roll!
|===========================================                   |  70%
| However, as is the case with many common tasks, R has a separate
| built-in function for this purpose called seq_along(). Type
| seq_along(my_seq) to see it in action.
> seq_along(my_seq)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22
[23] 23 24 25 26 27 28 29 30
| You got it right!
|==============================================                |  74%
| There are often several approaches to solving the same problem,
| particularly in R. Simple approaches that involve less typing are
| generally best. It's also important for your code to be readable, so
| that you and others can figure out what's going on without too much
| hassle.
...
|=================================================             |  78%
| If R has a built-in function for a particular task, it's likely that
| function is highly optimized for that purpose and is your best
| option. As you become a more advanced R programmer, you'll design
| your own functions to perform tasks when there are no better options.
| We'll explore writing your own functions in future lessons.
...
|===================================================           |  83%
| One more function related to creating sequences of numbers is rep(),
| which stands for 'replicate'. Let's look at a few uses.
...
|======================================================        |  87%
| If we're interested in creating a vector that contains 40 zeros, we
| can use rep(0, times = 40). Try it out.
> rep(0, times = 40)
 [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[35] 0 0 0 0 0 0
| Your dedication is inspiring!
|=========================================================     |  91%
| If instead we want our vector to contain 10 repetitions of the vector
| (0, 1, 2), we can do rep(c(0, 1, 2), times = 10). Go ahead.
> rep(c(0,1,2), times=10)
 [1] 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2
| You got it!
|===========================================================   |  96%
| Finally, let's say that rather than repeating the vector (0, 1, 2)
| over and over again, we want our vector to contain 10 zeros, then 10
| ones, then 10 twos. We can do this with the `each` argument. Try
| rep(c(0, 1, 2), each = 10).
> rep(c(0,1,2), each = 10)
 [1] 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2
| Nice work!
|==============================================================| 100%

##########
4. VECTORS
##########

|                                                              |   0%
| The simplest and most common data structure in R is the vector.
...
|==                                                            |   3%
| Vectors come in two different flavors: atomic vectors and lists. An
| atomic vector contains exactly one data type, whereas a list may
| contain multiple data types. We'll explore atomic vectors further
| before we get to lists.
...
|===                                                           |   5%
| In previous lessons, we dealt entirely with numeric vectors, which
| are one type of atomic vector. Other types of atomic vectors include
| logical, character, integer, and complex. In this lesson, we'll take
| a closer look at logical and character vectors.
...
|=====                                                         |   8%
| Logical vectors can contain the values TRUE, FALSE, and NA (for 'not
| available'). These values are generated as the result of logical
| 'conditions'. Let's experiment with some simple conditions.
...
|=======                                                       |  11%
| First, create a numeric vector num_vect that contains the values 0.5,
| 55, -10, and 6.
> num_vect <- c(0.5, 55, -10, 6)
| That's the answer I was looking for.
|========                                                      |  13%
| Now, create a variable called tf that gets the result of num_vect <
| 1, which is read as 'num_vect is less than 1'.
> tf <- num_vect < 1
| You are quite good my friend!
|==========                                                    |  16%
| What do you think tf will look like?
1: a single logical value
2: a vector of 4 logical values
Selection: 2
| Great job!
|===========                                                   |  18%
| Print the contents of tf now.
> tf
[1]  TRUE FALSE  TRUE FALSE
| Great job!
|=============                                                 |  21%
| The statement num_vect < 1 is a condition and tf tells us whether
| each corresponding element of our numeric vector num_vect satisfies
| this condition.
...
|===============                                               |  24%
| The first element of num_vect is 0.5, which is less than 1 and
| therefore the statement 0.5 < 1 is TRUE. The second element of
| num_vect is 55, which is greater than 1, so the statement 55 < 1 is
| FALSE. The same logic applies for the third and fourth elements.
...
|================                                              |  26%
| Let's try another. Type num_vect >= 6 without assigning the result to
| a new variable.
> num_vect >= 6
[1] FALSE  TRUE FALSE  TRUE
| Excellent work!
|==================                                            |  29%
| This time, we are asking whether each individual element of num_vect
| is greater than OR equal to 6. Since only 55 and 6 are greater than
| or equal to 6, the second and fourth elements of the result are TRUE
| and the first and third elements are FALSE.
...
|====================                                          |  32%
| The `<` and `>=` symbols in these examples are called 'logical
| operators'. Other logical operators include `>`, `<=`, `==` for exact
| equality, and `!=` for inequality.
...
|=====================                                         |  34%
| If we have two logical expressions, A and B, we can ask whether at
| least one is TRUE with A | B (logical 'or' a.k.a. 'union') or whether
| they are both TRUE with A & B (logical 'and' a.k.a. 'intersection').
| Lastly, !A is the negation of A and is TRUE when A is FALSE and vice
| versa.
...
|=======================                                       |  37%
| It's a good idea to spend some time playing around with various
| combinations of these logical operators until you get comfortable
| with their use. We'll do a few examples here to get you started.
…
|========================                                      |  39%
| Try your best to predict the result of each of the following
| statements. You can use pencil and paper to work them out if it's
| helpful. If you get stuck, just guess and you've got a 50% chance of
| getting the right answer!
...
|==========================                                    |  42%
| (3 > 5) & (4 == 4)
1: FALSE
2: TRUE
Selection: 1
| Great job!
|============================                                  |  45%
| (TRUE == TRUE) | (TRUE == FALSE)
1: FALSE
2: TRUE
Selection: 2
| You nailed it! Good job!
|=============================                                 |  47%
| ((111 >= 111) | !(TRUE)) & ((4 + 1) == 5)
1: FALSE
2: TRUE
Selection: 2
| You are doing so well!
|===============================                               |  50%
| Don't worry if you found these to be tricky. They're supposed to be.
| Working with logical statements in R takes practice, but your efforts
| will be rewarded in future lessons (e.g. subsetting and control
| structures).
...
|=================================                             |  53%
| Character vectors are also very common in R. Double quotes are used
| to distinguish character objects, as in the following example.
...
|==================================                            |  55%
| Create a character vector that contains the following words: "My",
| "name", "is". Remember to enclose each word in its own set of double
| quotes, so that R knows they are character strings. Store the vector
| in a variable called my_char.
> my_char <- c("My", "name", "is")
| You're the best!
|====================================                          |  58%
| Print the contents of my_char to see what it looks like.
> my_char
[1] "My"   "name" "is"  
| All that hard work is paying off!
|======================================                        |  61%
| Right now, my_char is a character vector of length 3. Let's say we
| want to join the elements of my_char together into one continuous
| character string (i.e. a character vector of length 1). We can do
| this using the paste() function.
...
|=======================================                       |  63%
| Type paste(my_char, collapse = " ") now. Make sure there's a space
| between the double quotes in the `collapse` argument. You'll see why
| in a second.
> paste(my_char, collapse = " ")
[1] "My name is"
| Great job!
|=========================================                     |  66%
| The `collapse` argument to the paste() function tells R that when we
| join together the elements of the my_char character vector, we'd like
| to separate them with single spaces.
...
|==========================================                    |  68%
| It seems that we're missing something.... Ah, yes! Your name!
...
|============================================                  |  71%
| To add (or 'concatenate') your name to the end of my_char, use the
| c() function like this: c(my_char, "your_name_here"). Place your name
| in double quotes where I've put "your_name_here". Try it now, storing
| the result in a new variable called my_name.
> my_name <- c(my_char, "Joao")
| You are really on a roll!
|==============================================                |  74%
| Take a look at the contents of my_name.
> my_name
[1] "My"   "name" "is"   "Joao"
| All that practice is paying off!
|===============================================               |  76%
| Now, use the paste() function once more to join the words in my_name
| together into a single character string. Don't forget to say collapse
| = " "!
> paste(my_name, collapse = " ")
[1] "My name is Joao"
| You got it!
|=================================================             |  79%
| In this example, we used the paste() function to collapse the
| elements of a single character vector. paste() can also be used to
| join the elements of multiple character vectors.
...
|===================================================           |  82%
| In the simplest case, we can join two character vectors that are each
| of length 1 (i.e. join two words). Try paste("Hello", "world!", sep =
| " "), where the `sep` argument tells R that we want to separate the
| joined elements with a single space.
> paste("Hello", "world!", sep = " ")
[1] "Hello world!"
| That's a job well done!
|====================================================          |  84%
| For a slightly more complicated example, we can join two vectors,
| each of length 3. Use paste() to join the integer vector 1:3 with the
| character vector c("X", "Y", "Z"). This time, use sep = "" to leave
| no space between the joined elements.
> paste(1:3,c("X", "Y", "Z"), sep = "")
[1] "1X" "2Y" "3Z"
| Great job!
|======================================================        |  87%
| What do you think will happen if our vectors are of different length?
| (Hint: we talked about this in a previous lesson.)
...
|=======================================================       |  89%
| Vector recycling! Try paste(LETTERS, 1:4, sep = "-"), where LETTERS
| is a predefined variable in R containing a character vector of all 26
| letters in the English alphabet.
> paste (LETTERS, 1:4, sep = "-")
 [1] "A-1" "B-2" "C-3" "D-4" "E-1" "F-2" "G-3" "H-4" "I-1" "J-2" "K-3"
[12] "L-4" "M-1" "N-2" "O-3" "P-4" "Q-1" "R-2" "S-3" "T-4" "U-1" "V-2"
[23] "W-3" "X-4" "Y-1" "Z-2"
| Perseverance, that's the answer.
|=========================================================     |  92%
| Since the character vector LETTERS is longer than the numeric vector
| 1:4, R simply recycles, or repeats, 1:4 until it matches the length
| of LETTERS.
...
|===========================================================   |  95%
| Also worth noting is that the numeric vector 1:4 gets 'coerced' into
| a character vector by the paste() function.
...
|============================================================  |  97%
| We'll discuss coercion in another lesson, but all it really means is
| that the numbers 1, 2, 3, and 4 in the output above are no longer
| numbers to R, but rather characters "1", "2", "3", and "4".
...
|==============================================================| 100%

#################
5. Missing values
#################

|                                                              |   0%
| Missing values play an important role in statistics and data
| analysis. Often, missing values must not be ignored, but rather they
| should be carefully studied to see if there's an underlying pattern
| or cause for their missingness.
...
|===                                                           |   5%
| In R, NA is used to represent any value that is 'not available' or
| 'missing' (in the statistical sense). In this lesson, we'll explore
| missing values further.
...
|======                                                        |  10%
| Any operation involving NA generally yields NA as the result. To
| illustrate, let's create a vector c(44, NA, 5, NA) and assign it to a
| variable x.
> c(44, NA, 5, NA) -> x
| You're the best!
|=========                                                     |  15%
| Now, let's multiply x by 3.
> x * 3
[1] 132  NA  15  NA
| You nailed it! Good job!
|============                                                  |  20%
| Notice that the elements of the resulting vector that correspond with
| the NA values in x are also NA.
...
|================                                              |  25%
| To make things a little more interesting, lets create a vector
| containing 1000 draws from a standard normal distribution with y <-
| rnorm(1000).
> rnorm(1000) -> y
| You are doing so well!
|===================                                           |  30%
| Next, let's create a vector containing 1000 NAs with z <- rep(NA,
| 1000).
> rep (NA, 1000) -> z
| Great job!
|======================                                        |  35%
| Finally, let's select 100 elements at random from these 2000 values
| (combining y and z) such that we don't know how many NAs we'll wind
| up with or what positions they'll occupy in our final vector --
| my_data <- sample(c(y, z), 100).
> sample(c(y,z), 100) -> my_data
| All that practice is paying off!
|=========================                                     |  40%
| Let's first ask the question of where our NAs are located in our
| data. The is.na() function tells us whether each element of a vector
| is NA. Call is.na() on my_data and assign the result to my_na.
> is.na(my_data) -> my_na
| You got it!
|============================                                  |  45%
| Now, print my_na to see what you came up with.
> my_na
  [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE
 [12] FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE
 [23] FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE
 [34]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE
 [45] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE
 [56]  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE
 [67] FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE
 [78] FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE
 [89] FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE
[100]  TRUE
| You are really on a roll!
|===============================                               |  50%
| Everywhere you see a TRUE, you know the corresponding element of
| my_data is NA. Likewise, everywhere you see a FALSE, you know the
| corresponding element of my_data is one of our random draws from the
| standard normal distribution.
...
|==================================                            |  55%
| In our previous discussion of logical operators, we introduced the
| `==` operator as a method of testing for equality between two
| objects. So, you might think the expression my_data == NA yields the
| same results as is.na(). Give it a try.
> my_data == NA
  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [23] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [45] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [67] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [89] NA NA NA NA NA NA NA NA NA NA NA NA
| Excellent work!
|=====================================                         |  60%
| The reason you got a vector of all NAs is that NA is not really a
| value, but just a placeholder for a quantity that is not available.
| Therefore the logical expression is incomplete and R has no choice
| but to return a vector of the same length as my_data that contains
| all NAs.
...
|========================================                      |  65%
| Don't worry if that's a little confusing. The key takeaway is to be
| cautious when using logical expressions anytime NAs might creep in,
| since a single NA value can derail the entire thing.
...
|===========================================                   |  70%
| So, back to the task at hand. Now that we have a vector, my_na, that
| has a TRUE for every NA and FALSE for every numeric value, we can
| compute the total number of NAs in our data.
...
|==============================================                |  75%
| The trick is to recognize that underneath the surface, R represents
| TRUE as the number 1 and FALSE as the number 0. Therefore, if we take
| the sum of a bunch of TRUEs and FALSEs, we get the total number of
| TRUEs.
...
|==================================================            |  80%
| Let's give that a try here. Call the sum() function on my_na to count
| the total number of TRUEs in my_na, and thus the total number of NAs
| in my_data. Don't assign the result to a new variable.
> sum(my_na)
[1] 48
| Your dedication is inspiring!
|=====================================================         |  85%
| Pretty cool, huh? Finally, let's take a look at the data to convince
| ourselves that everything 'adds up'. Print my_data to the console.
> my_data
  [1]           NA           NA           NA           NA           NA
  [6] -0.022213158           NA           NA           NA           NA
 [11]           NA -0.534045177           NA  1.002395387  1.001679963
 [16]           NA  0.761687396  0.458715255 -0.286529965           NA
 [21] -0.621670854           NA  0.257876158  0.240367010 -0.415734449
 [26]           NA           NA -0.872726653  0.564217667           NA
 [31]           NA -0.187679994           NA           NA           NA
 [36] -0.180512979  1.482428511  0.121522004 -0.308570986  0.268389614
 [41]           NA           NA  0.171540303  0.083629952  1.028878855
 [46]           NA  0.002780426           NA -0.973627932           NA
 [51] -0.595108088           NA           NA           NA           NA
 [56]           NA -1.063067768  1.366203196           NA -1.026830494
 [61]           NA           NA           NA  0.077548727           NA
 [66]           NA -0.540260146 -1.160600255 -0.330010408  0.309149041
 [71]           NA           NA  1.179216650 -1.762975966 -0.796310074
 [76]  1.627811090  1.037730884 -0.852078480           NA -0.358261414
 [81] -1.167030427 -0.492089892           NA  0.151136280           NA
 [86] -2.388814422           NA -1.062532638  0.105100479           NA
 [91] -2.339871094 -1.080589053  2.758771991           NA           NA
 [96]  0.250701580           NA  0.243768328 -0.860127153           NA
| Keep working like that and you'll get there!
|========================================================      |  90%
| Now that we've got NAs down pat, let's look at a second type of
| missing value -- NaN, which stands for 'not a number'. To generate
| NaN, try dividing (using a forward slash) 0 by 0 now.
> 0/0
[1] NaN
| Excellent job!
|===========================================================   |  95%
| Let's do one more, just for fun. In R, Inf stands for infinity. What
| happens if you subtract Inf from Inf?
> Inf - Inf
[1] NaN
| You're the best!
|==============================================================| 100%

#####################
6. Subsetting Vectors
#####################

|                                                              |   0%
| In this lesson, we'll see how to extract elements from a vector based
| on some conditions that we specify.
...
|==                                                            |   3%
| For example, we may only be interested in the first 20 elements of a
| vector, or only the elements that are not NA, or only those that are
| positive or correspond to a specific variable of interest. By the end
| of this lesson, you'll know how to handle each of these scenarios.
...
|===                                                           |   5%
| I've created for you a vector called x that contains a random
| ordering of 20 numbers (from a standard normal distribution) and 20
| NAs. Type x now to see what it looks like.
> x
 [1] -1.99518738          NA  0.95156781          NA          NA
 [6] -0.16524561  0.57422629          NA          NA          NA
[11]  0.56248775 -2.42583703  1.94129781  1.52711638 -1.94670026
[16] -1.01328842          NA          NA          NA          NA
[21] -0.05392393  0.24790719 -2.08467773 -1.67800404 -0.65019123
[26]  0.61381776          NA          NA          NA -0.46790219
[31]  1.53306733  0.70344703          NA          NA          NA
[36]  2.08983523          NA          NA          NA          NA
| You nailed it! Good job!
|=====                                                         |   8%
| The way you tell R that you want to select some particular elements
| (i.e. a 'subset') from a vector is by placing an 'index vector' in
| square brackets immediately following the name of the vector.
...
|======                                                        |  10%
| For a simple example, try x[1:10] to view the first ten elements of
| x.
> x[1:10]
 [1] -1.9951874         NA  0.9515678         NA         NA -0.1652456
 [7]  0.5742263         NA         NA         NA
| Excellent job!
|========                                                      |  13%
| Index vectors come in four different flavors -- logical vectors,
| vectors of positive integers, vectors of negative integers, and
| vectors of character strings -- each of which we'll cover in this
| lesson.
...
|==========                                                    |  15%
| Let's start by indexing with logical vectors. One common scenario
| when working with real-world data is that we want to extract all
| elements of a vector that are not NA (i.e. missing data). Recall that
| is.na(x) yields a vector of logical values the same length as x, with
| TRUEs corresponding to NA values in x and FALSEs corresponding to
| non-NA values in x.
...
|===========                                                   |  18%
| What do you think x[is.na(x)] will give you?
1: A vector of all NAs
2: A vector of TRUEs and FALSEs
3: A vector with no NAs
4: A vector of length 0
Selection: 1
| Keep up the great work!
|=============                                                 |  21%
| Prove it to yourself by typing x[is.na(x)].
> x[is.na(x)]
 [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
| You got it right!
|==============                                                |  23%
| Recall that `!` gives us the negation of a logical expression, so
| !is.na(x) can be read as 'is not NA'. Therefore, if we want to create
| a vector called y that contains all of the non-NA values from x, we
| can use y <- x[!is.na(x)]. Give it a try.
> y <- x[!is.na(x)]
| You are really on a roll!
|================                                              |  26%
| Print y to the console.
> y
 [1] -1.99518738  0.95156781 -0.16524561  0.57422629  0.56248775
 [6] -2.42583703  1.94129781  1.52711638 -1.94670026 -1.01328842
[11] -0.05392393  0.24790719 -2.08467773 -1.67800404 -0.65019123
[16]  0.61381776 -0.46790219  1.53306733  0.70344703  2.08983523
| Nice work!
|=================                                             |  28%
| Now that we've isolated the non-missing values of x and put them in
| y, we can subset y as we please.
...
|===================                                           |  31%
| Recall that the expression y > 0 will give us a vector of logical
| values the same length as y, with TRUEs corresponding to values of y
| that are greater than zero and FALSEs corresponding to values of y
| that are less than or equal to zero. What do you think y[y > 0] will
| give you?
1: A vector of all the positive elements of y
2: A vector of length 0
3: A vector of all NAs
4: A vector of TRUEs and FALSEs
5: A vector of all the negative elements of y
Selection: 1
| All that practice is paying off!
|=====================                                         |  33%
| Type y[y > 0] to see that we get all of the positive elements of y,
| which are also the positive elements of our original vector x.
> y[y > 0]
 [1] 0.9515678 0.5742263 0.5624877 1.9412978 1.5271164 0.2479072
 [7] 0.6138178 1.5330673 0.7034470 2.0898352
| You are really on a roll!
|======================                                        |  36%
| You might wonder why we didn't just start with x[x > 0] to isolate
| the positive elements of x. Try that now to see why.
> x[x > 0]
 [1]        NA 0.9515678        NA        NA 0.5742263        NA
 [7]        NA        NA 0.5624877 1.9412978 1.5271164        NA
[13]        NA        NA        NA 0.2479072 0.6138178        NA
[19]        NA        NA 1.5330673 0.7034470        NA        NA
[25]        NA 2.0898352        NA        NA        NA        NA

| You are quite good my friend!
|========================                                      |  38%
| Since NA is not a value, but rather a placeholder for an unknown
| quantity, the expression NA > 0 evaluates to NA. Hence we get a bunch
| of NAs mixed in with our positive numbers when we do this.
...
|=========================                                     |  41%
| Combining our knowledge of logical operators with our new knowledge
| of subsetting, we could do this -- x[!is.na(x) & x > 0]. Try it out.
> x[!is.na(x) & x > 0]
 [1] 0.9515678 0.5742263 0.5624877 1.9412978 1.5271164 0.2479072
 [7] 0.6138178 1.5330673 0.7034470 2.0898352
| You nailed it! Good job!
|===========================                                   |  44%
| In this case, we request only values of x that are both non-missing
| AND greater than zero.
...
|=============================                                 |  46%
| I've already shown you how to subset just the first ten values of x
| using x[1:10]. In this case, we're providing a vector of positive
| integers inside of the square brackets, which tells R to return only
| the elements of x numbered 1 through 10.
...
|==============================                                |  49%
| Many programming languages use what's called 'zero-based indexing',
| which means that the first element of a vector is considered element
| 0. R uses 'one-based indexing', which (you guessed it!) means the
| first element of a vector is considered element 1.
...
|================================                              |  51%
| Can you figure out how we'd subset the 3rd, 5th, and 7th elements of
| x? Hint -- Use the c() function to specify the element numbers as a
| numeric vector.
> x[c(1,3,5)]
[1] -1.9951874  0.9515678         NA
| That's not the answer I was looking for, but try again. Or, type
| info() for more options.
| Create a vector of indexes with c(3, 5, 7), then put that inside of
| the square brackets.
> x[c(3,5,7)]
[1] 0.9515678        NA 0.5742263

| You are really on a roll!
|=================================                             |  54%
| It's important that when using integer vectors to subset our vector
| x, we stick with the set of indexes {1, 2, ..., 40} since x only has
| 40 elements. What happens if we ask for the zeroth element of x (i.e.
| x[0])? Give it a try.
> x[0]
numeric(0)

| That's a job well done!
|===================================                           |  56%
| As you might expect, we get nothing useful. Unfortunately, R doesn't
| prevent us from doing this. What if we ask for the 3000th element of
| x? Try it out.
> x[3000]
[1] NA
| You are doing so well!
|=====================================                         |  59%
| Again, nothing useful, but R doesn't prevent us from asking for it.
| This should be a cautionary tale. You should always make sure that
| what you are asking for is within the bounds of the vector you're
| working with.
...
|======================================                        |  62%
| What if we're interested in all elements of x EXCEPT the 2nd and
| 10th? It would be pretty tedious to construct a vector containing all
| numbers 1 through 40 EXCEPT 2 and 10.
...
|========================================                      |  64%
| Luckily, R accepts negative integer indexes. Whereas x[c(2, 10)]
| gives us ONLY the 2nd and 10th elements of x, x[c(-2, -10)] gives us
| all elements of x EXCEPT for the 2nd and 10 elements.  Try x[c(-2,
| -10)] now to see this.
> x[c(-2,-10)]
 [1] -1.99518738  0.95156781          NA          NA -0.16524561
 [6]  0.57422629          NA          NA  0.56248775 -2.42583703
[11]  1.94129781  1.52711638 -1.94670026 -1.01328842          NA
[16]          NA          NA          NA -0.05392393  0.24790719
[21] -2.08467773 -1.67800404 -0.65019123  0.61381776          NA
[26]          NA          NA -0.46790219  1.53306733  0.70344703
[31]          NA          NA          NA  2.08983523          NA
[36]          NA          NA          NA
| You got it right!
|=========================================                     |  67%
| A shorthand way of specifying multiple negative numbers is to put the
| negative sign out in front of the vector of positive numbers. Type
| x[-c(2, 10)] to get the exact same result.
> x[-c(2,10)]
 [1] -1.99518738  0.95156781          NA          NA -0.16524561
 [6]  0.57422629          NA          NA  0.56248775 -2.42583703
[11]  1.94129781  1.52711638 -1.94670026 -1.01328842          NA
[16]          NA          NA          NA -0.05392393  0.24790719
[21] -2.08467773 -1.67800404 -0.65019123  0.61381776          NA
[26]          NA          NA -0.46790219  1.53306733  0.70344703
[31]          NA          NA          NA  2.08983523          NA
[36]          NA          NA          NA
| You got it!
|===========================================                   |  69%
| So far, we've covered three types of index vectors -- logical,
| positive integer, and negative integer. The only remaining type
| requires us to introduce the concept of 'named' elements.
...
|=============================================                 |  72%
| Create a numeric vector with three named elements using vect <- c(foo
| = 11, bar = 2, norf = NA).
> vect <- c(foo = 11, bar = 2, norf = NA)
| Perseverance, that's the answer.
|==============================================                |  74%
| When we print vect to the console, you'll see that each element has a
| name. Try it out.
> vect
 foo  bar norf 
  11    2   NA 
| You got it right!
|================================================              |  77%
| We can also get the names of vect by passing vect as an argument to
| the names() function. Give that a try.
> names(vect)
[1] "foo"  "bar"  "norf"
| You are doing so well!
|=================================================             |  79%
| Alternatively, we can create an unnamed vector vect2 with c(11, 2,
| NA). Do that now.
> vect2 <- c(11, 2, NA)
| Keep up the great work!
|===================================================           |  82%
| Then, we can add the `names` attribute to vect2 after the fact with
| names(vect2) <- c("foo", "bar", "norf"). Go ahead.
> names(vect2) <- c("foo", "bar", "norf")
| You're the best!
|====================================================          |  85%
| Now, let's check that vect and vect2 are the same by passing them as
| arguments to the identical() function.
> vect2
 foo  bar norf 
  11    2   NA 
| You're close...I can feel it! Try it again. Or, type info() for more
| options.
| The identical() function tells us if its first two arguments are,
| well, identical.
> identical(vect, vect2)
[1] TRUE
| Excellent work!
|======================================================        |  87%
| Indeed, vect and vect2 are identical named vectors.
...
|========================================================      |  90%
| Now, back to the matter of subsetting a vector by named elements.
| Which of the following commands do you think would give us the second
| element of vect?
1: vect[bar]
2: vect["bar"]
3: vect["2"]
Selection: 2
| Nice work!
|=========================================================     |  92%
| Now, try it out.
> vect["bar"]
bar 
  2 
| Excellent work!
|===========================================================   |  95%
| Likewise, we can specify a vector of names with vect[c("foo",
| "bar")]. Try it out.
> vect[c("foo", "bar")]
foo bar 
 11   2 
| You are really on a roll!
|============================================================  |  97%
| Now you know all four methods of subsetting data from vectors.
| Different approaches are best in different scenarios and when in
| doubt, try it out!
...
|==============================================================| 100%

###########################
7. Matrices and Data Frames
###########################

|                                                              |   0%
| In this lesson, we'll cover matrices and data frames. Both represent
| 'rectangular' data types, meaning that they are used to store tabular
| data, with rows and columns.
...
|==                                                            |   3%
| The main difference, as you'll see, is that matrices can only contain
| a single class of data, while data frames can consist of many
| different classes of data.
...
|===                                                           |   6%
| Let's create a vector containing the numbers 1 through 20 using the
| `:` operator. Store the result in a variable called my_vector.
> my_vector <- 1:20
| You are amazing!
|=====                                                         |   8%
| View the contents of the vector you just created.
> my_vector
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
| Excellent work!
|=======                                                       |  11%
| The dim() function tells us the 'dimensions' of an object. What
| happens if we do dim(my_vector)? Give it a try.
> dim(my_vector)
NULL
| You got it right!
|=========                                                     |  14%
| Clearly, that's not very helpful! Since my_vector is a vector, it
| doesn't have a `dim` attribute (so it's just NULL), but we can find
| its length using the length() function. Try that now.
> 
> length(my_vector)
[1] 20
| You nailed it! Good job!
|==========                                                    |  17%
| Ah! That's what we wanted. But, what happens if we give my_vector a
| `dim` attribute? Let's give it a try. Type dim(my_vector) <- c(4, 5).
> dim(my_vector) <- c(4,5)
| Excellent work!
|============                                                  |  19%
| It's okay if that last command seemed a little strange to you. It
| should! The dim() function allows you to get OR set the `dim`
| attribute for an R object. In this case, we assigned the value c(4,
| 5) to the `dim` attribute of my_vector.
...
|==============                                                |  22%
| Use dim(my_vector) to confirm that we've set the `dim` attribute
| correctly.
> dim(my_vector)
[1] 4 5
| You are amazing!
|================                                              |  25%
| Another way to see this is by calling the attributes() function on
| my_vector. Try it now.
> attributes(my_vector)
$dim
[1] 4 5
| All that hard work is paying off!
|=================                                             |  28%
| Just like in math class, when dealing with a 2-dimensional object
| (think rectangular table), the first number is the number of rows and
| the second is the number of columns. Therefore, we just gave
| my_vector 4 rows and 5 columns.
...
|===================                                           |  31%
| But, wait! That doesn't sound like a vector any more. Well, it's not.
| Now it's a matrix. View the contents of my_vector now to see what it
| looks like.
> my_vector
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20
| Nice work!
|=====================                                         |  33%
| Now, let's confirm it's actually a matrix by using the class()
| function. Type class(my_vector) to see what I mean.
> class(my_vector)
[1] "matrix"
| You are quite good my friend!
|======================                                        |  36%
| Sure enough, my_vector is now a matrix. We should store it in a new
| variable that helps us remember what it is. Store the value of
| my_vector in a new variable called my_matrix.
> my_matrix <- my_vector
| You're the best!
|========================                                      |  39%
| The example that we've used so far was meant to illustrate the point
| that a matrix is simply an atomic vector with a dimension attribute.
| A more direct method of creating the same matrix uses the matrix()
| function.
...
|==========================                                    |  42%
| Bring up the help file for the matrix() function now using the `?`
| function.
> ?matrix
| All that hard work is paying off!
|============================                                  |  44%
| Now, look at the documentation for the matrix function and see if you
| can figure out how to create a matrix containing the same numbers
| (1-20) and dimensions (4 rows, 5 columns) by calling the matrix()
| function. Store the result in a variable called my_matrix2.
> matrix(1:20,4,5) -> my_matrix2
| You are quite good my friend!
|=============================                                 |  47%
| Finally, let's confirm that my_matrix and my_matrix2 are actually
| identical. The identical() function will tell us if its first two
| arguments are the same. Try it out.
> identical(my_matrix,my_matrix2)
[1] TRUE

| All that practice is paying off!
|===============================                               |  50%
| Now, imagine that the numbers in our table represent some
| measurements from a clinical experiment, where each row represents
| one patient and each column represents one variable for which
| measurements were taken.
...
|=================================                             |  53%
| We may want to label the rows, so that we know which numbers belong
| to each patient in the experiment. One way to do this is to add a
| column to the matrix, which contains the names of all four people.
...
|==================================                            |  56%
| Let's start by creating a character vector containing the names of
| our patients -- Bill, Gina, Kelly, and Sean. Remember that double
| quotes tell R that something is a character string. Store the result
| in a variable called patients.
> c('Bill', 'Gina', 'Kelly', 'Sean') -> patients
| That's the answer I was looking for.
|====================================                          |  58%
| Now we'll use the cbind() function to 'combine columns'. Don't worry
| about storing the result in a new variable. Just call cbind() with
| two arguments -- the patients vector and my_matrix.
> cbind(patients, my_matrix)
     patients                       
[1,] "Bill"   "1" "5" "9"  "13" "17"
[2,] "Gina"   "2" "6" "10" "14" "18"
[3,] "Kelly"  "3" "7" "11" "15" "19"
[4,] "Sean"   "4" "8" "12" "16" "20"
| Excellent job!
|======================================                        |  61%
| Something is fishy about our result! It appears that combining the
| character vector with our matrix of numbers caused everything to be
| enclosed in double quotes. This means we're left with a matrix of
| character strings, which is no good.
...
|========================================                      |  64%
| If you remember back to the beginning of this lesson, I told you that
| matrices can only contain ONE class of data. Therefore, when we tried
| to combine a character vector with a numeric matrix, R was forced to
| 'coerce' the numbers to characters, hence the double quotes.
...
|=========================================                     |  67%
| This is called 'implicit coercion', because we didn't ask for it. It
| just happened. But why didn't R just convert the names of our
| patients to numbers? I'll let you ponder that question on your own.
...
|===========================================                   |  69%
| So, we're still left with the question of how to include the names of
| our patients in the table without destroying the integrity of our
| numeric data. Try the following -- my_data <- data.frame(patients,
| my_matrix)
> my_data <- data.frame(patients,my_matrix)
| That's correct!
|=============================================                 |  72%
| Now view the contents of my_data to see what we've come up with.
> my_data
  patients X1 X2 X3 X4 X5
1     Bill  1  5  9 13 17
2     Gina  2  6 10 14 18
3    Kelly  3  7 11 15 19
4     Sean  4  8 12 16 20
| That's correct!
|==============================================                |  75%
| It looks like the data.frame() function allowed us to store our
| character vector of names right alongside our matrix of numbers.
| That's exactly what we were hoping for!
...
|================================================              |  78%
| Behind the scenes, the data.frame() function takes any number of
| arguments and returns a single object of class `data.frame` that is
| composed of the original objects.
...
|==================================================            |  81%
| Let's confirm this by calling the class() function on our newly
| created data frame.
> class(my_data)
[1] "data.frame"
| Nice work!
|====================================================          |  83%
| It's also possible to assign names to the individual rows and columns
| of a data frame, which presents another possible way of determining
| which row of values in our table belongs to each patient.
...
|=====================================================         |  86%
| However, since we've already solved that problem, let's solve a
| different problem by assigning names to the columns of our data frame
| so that we know what type of measurement each column represents.
...
|=======================================================       |  89%
| Since we have six columns (including patient names), we'll need to
| first create a vector containing one element for each column. Create
| a character vector called cnames that contains the following values
| (in order) -- "patient", "age", "weight", "bp", "rating", "test".
> cnames <- c('patient','age','weight','bp','rating','test')
| You are amazing!
|=========================================================     |  92%
| Now, use the colnames() function to set the `colnames` attribute for
| our data frame. This is similar to the way we used the dim() function
| earlier in this lesson.
> colnames(my_data) <- cnames
| All that practice is paying off!
|===========================================================   |  94%
| Let's see if that got the job done. Print the contents of my_data.
> my_data
  patient age weight bp rating test
1    Bill   1      5  9     13   17
2    Gina   2      6 10     14   18
3   Kelly   3      7 11     15   19
4    Sean   4      8 12     16   20
| You got it right!
|============================================================  |  97%
| In this lesson, you learned the basics of working with two very
| important and common data structures -- matrices and data frames.
| There's much more to learn and we'll be covering more advanced
| topics, particularly with respect to data frames, in future lessons.
...
|==============================================================| 100%

########
8. Logic
########

|                                                              |   0%
| This lesson is meant to be a short introduction to logical operations
| in R.
...
|=                                                             |   2%
| There are two logical values in R, also called boolean values. They
| are TRUE and FALSE. In R you can construct logical expressions which
| will evaluate to either TRUE or FALSE.
...
|==                                                            |   4%
| Many of the questions in this lesson will involve evaluating logical
| expressions. It may be useful to open up a second R terminal where
| you can experiment with some of these expressions.
...
|====                                                          |   6%
| Creating logical expressions requires logical operators. You're
| probably familiar with arithmetic operators like `+`, `-`, `*`, and
| `/`. The first logical operator we are going to discuss is the
| equality operator, represented by two equals signs `==`. Use the
| equality operator below to find out if TRUE is equal to TRUE.
> TRUE==TRUE
[1] TRUE
| You nailed it! Good job!
|=====                                                         |   8%
| Just like arithmetic, logical expressions can be grouped by
| parenthesis so that the entire expression (TRUE == TRUE) == TRUE
| evaluates to TRUE.
...
|======                                                        |  10%
| To test out this property, try evaluating (FALSE == TRUE) == FALSE .
> (FALSE == TRUE) == FALSE
[1] TRUE
| You are amazing!
|=======                                                       |  12%
| The equality operator can also be used to compare numbers. Use `==`
| to see if 6 is equal to 7.
> 6 == 7
[1] FALSE
| All that hard work is paying off!
|========                                                      |  13%
| The previous expression evaluates to FALSE because 6 is less than 7.
| Thankfully, there are inequality operators that allow us to test if a
| value is less than or greater than another value.
...
|==========                                                    |  15%
| The less than operator `<` tests whether the number on the left side
| of the operator (called the left operand) is less than the number on
| the right side of the operator (called the right operand). Write an
| expression to test whether 6 is less than 7.
> 6 < 7
[1] TRUE
| You are really on a roll!
|===========                                                   |  17%
| There is also a less-than-or-equal-to operator `<=` which tests
| whether the left operand is less than or equal to the right operand.
| Write an expression to test whether 10 is less than or equal to 10.
> 
> 10 <= 10
[1] TRUE
| You are quite good my friend!
|============                                                  |  19%
| Keep in mind that there are the corresponding greater than `>` and
| greater-than-or-equal-to `>=` operators.
...
|=============                                                 |  21%
| Which of the following evaluates to FALSE?
1: 0 > -36
2: 6 < 8
3: 7 == 7
4: 9 >= 10
Selection: 4
| You got it!
|==============                                                |  23%
| Which of the following evaluates to TRUE?
1: -6 > -7
2: 7 == 9
3: 57 < 8
4: 9 >= 10
Selection: 1
| Perseverance, that's the answer.
|================                                              |  25%
| The next operator we will discuss is the 'not equals' operator
| represented by `!=`. Not equals tests whether two values are unequal,
| so TRUE != FALSE evaluates to TRUE. Like the equality operator, `!=`
| can also be used with numbers. Try writing an expression to see if 5
| is not equal to 7.
> 5 != 7
[1] TRUE
| All that hard work is paying off!
|=================                                             |  27%
| In order to negate boolean expressions you can use the NOT operator.
| An exclamation point `!` will cause !TRUE (say: not true) to evaluate
| to FALSE and !FALSE (say: not false) to evaluate to TRUE. Try using
| the NOT operator and the equals operator to find the opposite of
| whether 5 is equal to 7.
> !5 == 7
[1] TRUE
| You nailed it! Good job!
|==================                                            |  29%
| Let's take a moment to review. The equals operator `==` tests whether
| two boolean values or numbers are equal, the not equals operator `!=`
| tests whether two boolean values or numbers are unequal, and the NOT
| operator `!` negates logical expressions so that TRUE expressions
| become FALSE and FALSE expressions become TRUE.
...
|===================                                           |  31%
| Which of the following evaluates to FALSE?
1: 7 != 8
2: 9 < 10
3: !(0 >= -1)
4: !FALSE
Selection: 3
| Keep up the great work!
|====================                                          |  33%
| What do you think the following expression will evaluate to?: (TRUE
| != FALSE) == !(6 == 7)
1: TRUE
2: Can there be objective truth when programming?
3: %>%
4: FALSE
Selection: 1
| That's a job well done!
|=====================                                         |  35%
| At some point you may need to examine relationships between multiple
| logical expressions. This is where the AND operator and the OR
| operator come in.
...
|=======================                                       |  37%
| Let's look at how the AND operator works. There are two AND operators
| in R, `&` and `&&`. Both operators work similarly, if the right and
| left operands of AND are both TRUE the entire expression is TRUE,
| otherwise it is FALSE. For example, TRUE & TRUE evaluates to TRUE.
| Try typing FALSE & FALSE to how it is evaluated.
> FALSE & FALSE
[1] FALSE
| Keep working like that and you'll get there!
|========================                                      |  38%
| You can use the `&` operator to evaluate AND across a vector. The
| `&&` version of AND only evaluates the first member of a vector.
| Let's test both for practice. Type the expression TRUE & c(TRUE,
| FALSE, FALSE).
> TRUE & c(TRUE, FALSE, FALSE)
[1]  TRUE FALSE FALSE
| Your dedication is inspiring!
|=========================                                     |  40%
| What happens in this case is that the left operand `TRUE` is recycled
| across every element in the vector of the right operand. This is the
| equivalent statement as c(TRUE, TRUE, TRUE) & c(TRUE, FALSE, FALSE).
...
|==========================                                    |  42%
| Now we'll type the same expression except we'll use the `&&`
| operator. Type the expression TRUE && c(TRUE, FALSE, FALSE).
> TRUE && c(TRUE, FALSE, FALSE)
[1] TRUE
| You got it right!
|===========================                                   |  44%
| In this case, the left operand is only evaluated with the first
| member of the right operand (the vector). The rest of the elements in
| the vector aren't evaluated at all in this expression.
...
|=============================                                 |  46%
| The OR operator follows a similar set of rules. The `|` version of OR
| evaluates OR across an entire vector, while the `||` version of OR
| only evaluates the first member of a vector.
...
|==============================                                |  48%
| An expression using the OR operator will evaluate to TRUE if the left
| operand or the right operand is TRUE. If both are TRUE, the
| expression will evaluate to TRUE, however if neither are TRUE, then
| the expression will be FALSE.
...
|===============================                               |  50%
| Let's test out the vectorized version of the OR operator. Type the
| expression TRUE | c(TRUE, FALSE, FALSE).
> TRUE | c(TRUE, FALSE, FALSE)
[1] TRUE TRUE TRUE
| Excellent job!
|================================                              |  52%
| Now let's try out the non-vectorized version of the OR operator. Type
| the expression TRUE || c(TRUE, FALSE, FALSE).
> TRUE || c(TRUE, FALSE, FALSE)
[1] TRUE
| You are really on a roll!
|=================================                             |  54%
| Logical operators can be chained together just like arithmetic
| operators. The expressions: `6 != 10 && FALSE && 1 >= 2` or `TRUE ||
| 5 < 9.3 || FALSE` are perfectly normal to see.
...
|===================================                           |  56%
| As you may recall, arithmetic has an order of operations and so do
| logical expressions. All AND operators are evaluated before OR
| operators. Let's look at an example of an ambiguous case. Type: 5 > 8
| || 6 != 8 && 4 > 3.9
> 5 > 8 || 6 != 8 && 4 > 3.9
[1] TRUE
| You are amazing!
|====================================                          |  58%
| Let's walk through the order of operations in the above case. First
| the left and right operands of the AND operator are evaluated. 6 is
| not equal 8, 4 is greater than 3.9, therefore both operands are TRUE
| so the resulting expression `TRUE && TRUE` evaluates to TRUE. Then
| the left operand of the OR operator is evaluated: 5 is not greater
| than 8 so the entire expression is reduced to FALSE || TRUE. Since
| the right operand of this expression is TRUE the entire expression
| evaluates to TRUE.
...
|=====================================                         |  60%
| Which one of the following expressions evaluates to TRUE?
1: TRUE && FALSE || 9 >= 4 && 3 < 6
2: 99.99 > 100 || 45 < 7.3 || 4 != 4.0
3: TRUE && 62 < 62 && 44 >= 44
4: FALSE || TRUE && FALSE
Selection: 1
| All that hard work is paying off!
|======================================                        |  62%
| Which one of the following expressions evaluates to FALSE?
1: 6 >= -9 && !(6 > 7) && !(!TRUE)
2: FALSE || TRUE && 6 != 4 || 9 > 4
3: FALSE && 6 >= 6 || 7 >= 8 || 50 <= 49.5
4: !(8 > 4) ||  5 == 5.0 && 7.8 >= 7.79
Selection: 3
| That's correct!
|=======================================                       |  63%
| Now that you're familiar with R's logical operators you can take
| advantage of a few functions that R provides for dealing with logical
| expressions.
...
|=========================================                     |  65%
| The function isTRUE() takes one argument. If that argument evaluates
| to TRUE, the function will return TRUE. Otherwise, the function will
| return FALSE. Try using this function by typing: isTRUE(6 > 4)
> isTRUE(6 > 4)
[1] TRUE
| Your dedication is inspiring!
|==========================================                    |  67%
| Which of the following evaluates to TRUE?
1: isTRUE(NA)
2: isTRUE(3)
3: isTRUE(!TRUE)
4: !isTRUE(4 < 3)
5: !isTRUE(8 != 5)
Selection: 3
| You are doing so well!
|===========================================                   |  69%
| The function identical() will return TRUE if the two R objects passed
| to it as arguments are identical. Try out the identical() function by
| typing: identical('twins', 'twins')
> identical('twins','twins')
[1] TRUE
| You got it right!
|============================================                  |  71%
| Which of the following evaluates to TRUE?
1: identical(5 > 4, 3 < 3.1)
2: identical('hello', 'Hello')
3: !identical(7, 7)
4: identical(4, 3.1)
Selection: 1
| Excellent work!
|=============================================                 |  73%
| You should also be aware of the xor() function, which takes two
| arguments. The xor() function stands for exclusive OR. If one
| argument evaluates to TRUE and one argument evaluates to FALSE, then
| this function will return TRUE, otherwise it will return FALSE. Try
| out the xor() function by typing: xor(5 == 6, !FALSE)
> xor(5==6,!FALSE)
[1] TRUE
| You are amazing!
|==============================================                |  75%
| 5 == 6 evaluates to FALSE, !FALSE evaluates to TRUE, so xor(FALSE,
| TRUE) evaluates to TRUE. On the other hand if the first argument was
| changed to 5 == 5 and the second argument was unchanged then both
| arguments would have been TRUE, so xor(TRUE, TRUE) would have
| evaluated to FALSE.
...
|================================================              |  77%
| Which of the following evaluates to FALSE?
1: xor(identical(xor, 'xor'), 7 == 7.0)
2: xor(!!TRUE, !!FALSE)
3: xor(4 >= 9, 8 != 8.0)
4: xor(!isTRUE(TRUE), 6 > -1)
Selection: 3
| Perseverance, that's the answer.
|=================================================             |  79%
| For the next few questions, we're going to need to create a vector of
| integers called ints. Create this vector by typing: ints <-
| sample(10)
> ints <- sample(10)
| Your dedication is inspiring!
|==================================================            |  81%
| Now simply display the contents of ints.
> ints
 [1]  8  9  7  5  2  1  3  6  4 10
| Excellent work!
|===================================================           |  83%
| The vector `ints` is a random sampling of integers from 1 to 10
| without replacement. Let's say we wanted to ask some logical
| questions about contents of ints. If we type ints > 5, we will get a
| logical vector corresponding to whether each element of ints is
| greater than 5. Try typing: ints > 5
> ints > 5
 [1]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE
| You are quite good my friend!
|====================================================          |  85%
| We can use the resulting logical vector to ask other questions about
| ints. The which() function takes a logical vector as an argument and
| returns the indices of the vector that are TRUE. For example
| which(c(TRUE, FALSE, TRUE)) would return the vector c(1, 3).
...
|======================================================        |  87%
| Use the which() function to find the indices of ints that are greater
| than 7.
> which(ints > 7)
[1]  1  2 10
| That's a job well done!
|=======================================================       |  88%
| Which of the following commands would produce the indices of the
| elements in ints that are less than or equal to 2?
1: ints <= 2
2: ints < 2
3: which(ints < 2)
4: which(ints <= 2)
Selection: 4
| All that hard work is paying off!
|========================================================      |  90%
| Like the which() function, the functions any() and all() take logical
| vectors as their argument. The any() function will return TRUE if one
| or more of the elements in the logical vector is TRUE. The all()
| function will return TRUE if every element in the logical vector is
| TRUE.
...
|=========================================================     |  92%
| Use the any() function to see if any of the elements of ints are less
| than zero.
> any(ints < 0)
[1] FALSE
| You nailed it! Good job!
|==========================================================    |  94%
| Use the all() function to see if all of the elements of ints are
| greater than zero.
> all(ints>0)
[1] TRUE
| You are quite good my friend!
|============================================================  |  96%
| Which of the following evaluates to TRUE?
1: all(c(TRUE, FALSE, TRUE))
2: any(ints == 10)
3: all(ints == 10)
4: any(ints == 2.5)
Selection: 2
| That's correct!
|============================================================= |  98%
| That's all for this introduction to logic in R. If you really want to
| see what you can do with logic, check out the control flow lesson!
...
|==============================================================| 100%

############
9. Functions
############

|                                                                              |   0%

| Functions are one of the fundamental building blocks of the R language. They are
| small pieces of reusable code that can be treated like any other R object.

...

|==                                                                            |   2%

| If you've worked through any other part of this course, you've probably used some
| functions already. Functions are usually characterized by the name of the function
| followed by parentheses.

...

|===                                                                           |   4%

| Let's try using a few basic functions just for fun. The Sys.Date() function returns a
| string representing today's date. Type Sys.Date() below and see what happens.

> Sys.Date()
[1] "2015-03-08"

| All that practice is paying off!

|=====                                                                         |   6%

| Most functions in R return a value. Functions like Sys.Date() return a value based on
| your computer's environment, while other functions manipulate input data in order to
| compute a return value.

...

|======                                                                        |   8%

| The mean() function takes a vector of numbers as input, and returns the average of
| all of the numbers in the input vector. Inputs to functions are often called
| arguments. Providing arguments to a function is also sometimes called passing
| arguments to that function. Arguments you want to pass to a function go inside the
| function's parentheses. Try passing the argument c(2, 4, 5) to the mean() function.

> mean(c(2, 5, 5))
[1] 4

| You almost had it, but not quite. Try again. Or, type info() for more options.

| Compute the average of 2, 4, and 5 by typing: mean(c(2, 4, 5))

> mean(c(2, 4, 5))
[1] 3.666667

| Your dedication is inspiring!

|========                                                                      |  10%

| Functions usually take arguments which are variables that the function operates on.
| For example, the mean() function takes a vector as as argument, like in the case of
| mean(c(2,6,8)). The mean() function then adds up all of the numbers in the vector and
| divides that sum by the length of the vector.

...

|==========                                                                    |  12%

| In the following question you will be asked to modify a script that will appear as
| soon as you move on from this question. When you have finished modifying the script,
| save your changes to the script and type submit() and the script will be evaluated.
| There will be some comments in the script that opens up, so be sure to read them!
Now edit and save the R script boring_function.R.

# You're about to write your first function! Just like you would assign a value 
# to a variable with the assignment operator, you assign functions in the following
# way:
#
# function_name <- function(arg1, arg2){
#	# Maipulate arguments in some way
#	# Return a value
# }
#
# The "variable name" you assign will become the name of your function. arg1 and
# arg2 represent the arguments of your function. You can maipulate the arguments
# you specify within the function. After sourcing the function, you can use the 
# function by typing:
# 
# function_name(value1, value2)
#
# Below we will create a function called boring_function. This function takes
# the argument `x` as input, and returns the value of x without modifying it.
# Delete the pound sign in front of the x to make the function work! Be sure to 
# save this script and type submit() in the console after you make your changes.

boring_function <- function(x) {
  x
}
Back to console.

|===========                                                                   |  15%

| The last R expression to be evaluated in a function will become the return value of
| that function. We want this function to take one argument, x, and return x without
| modifying it. Delete the pound sign so that x is returned without any modification.
| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| Great job!

|=============                                                                 |  17%

| Now that you've created your first function let's test it! Type: boring_function('My
| first function!'). If your function works, it should just return the string: 'My
| first function!'

> boring_function('my first function!')
[1] "my first function!"

| Keep trying! Or, type info() for more options.

| Test boring_function by typing: boring_function('My first function!')

> boring_function('My first function!')
[1] "My first function!"

| Excellent work!

|===============                                                               |  19%

| Congratulations on writing your first function. By writing functions, you can gain
| serious insight into how R works. As John Chambers, the creator of R once said:
| 
| To understand computations in R, two slogans are helpful: 1. Everything that exists
| is an object. 2. Everything that happens is a function call.

...

|================                                                              |  21%

| If you want to see the source code for any function, just type the function name
| without any arguments or parentheses. Let's try this out with the function you just
| created. Type: boring_function to view its source code.

> boring_function
function(x) {
  x
}

| Your dedication is inspiring!

|==================                                                            |  23%

| Time to make a more useful function! We're going to replicate the functionality of
| the mean() function by creating a function called: my_mean(). Remember that to
| calculate the average of all of the numbers in a vector you find the sum of all the
| numbers in the vector, and then divide that sum by the number of numbers in the
| vector.

...

|====================                                                          |  25%

| Make sure to save your script before you type submit().

...
Now edit and save the R script my_mean.R.

# You're free to implement the function my_mean however you want, as long as it
# returns the average of all of the numbers in `my_vector`.
#
# Hint #1: sum() returns the sum of a vector.
# 	Ex: sum(c(1, 2, 3)) evaluates to 6
#
# Hint #2: length() returns the size of a vector.
# 	Ex: length(c(1, 2, 3)) evaluates to 3
#
# Hint #3: The mean of all the numbers in a vector is equal to the sum of all of
#		   the numbers in the vector divided by the size of the vector.
#
# Note for those of you feeling super clever: Please do not use the mean()
# function while writing this function. We're trying to teach you something 
# here!
#
# Be sure to save this script and type submit() in the console after you make 
# your changes.

my_mean <- function(my_vector) {
  # Write your code here!
  # Remember: the last expression evaluated will be returned! 
  sum(my_vector) / length(my_vector)
}
Now back to R Console.

|====================                                                          |  25%

| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| Excellent job!

|=====================                                                         |  27%

| Now test out your my_mean() function by finding the mean of the vector c(4, 5, 10).

> my_mean(c(4, 5, 10))
[1] 6.333333

| You got it!

|=======================                                                       |  29%

| Next, let's try writing a function with default arguments. You can set default values
| for a function's argumets, and this can be useful if you think someone who uses your
| funciton will set a certain argument to the same value most of the time.

...

|========================                                                      |  31%

| Make sure to save your script before you type submit().
Now edit and save remainder.R.

# Let me show you an example of a function I'm going to make up called
# increment(). Most of the time I want to use this function to increase the
# value of a number by one. This function will take two arguments: "number" and
# "by" where "number" is the digit I want to increment and "by" is the amount I
# want to increment "number" by. I've written the function below. 
#
# increment <- function(number, by = 1){
#     number + by
# }
#
# If you take a look in between the parentheses you can see that I've set
# "by" equal to 1. This means that the "by" argument will have the default
# value of 1.
#
# I can now use the increment function without providing a value for "by": 
# increment(5) will evaluate to 6. 
#
# However if I want to provide a value for the "by" argument I still can! The
# expression: increment(5, 2) will evaluate to 7. 
# 
# You're going to write a function called "remainder." remainder() will take
# two arguments: "num" and "divisor" where "num" is divided by "divisor" and
# the remainder is returned. Imagine that you usually want to know the remainder
# when you divide by 2, so set the default value of "divisor" to 2. Please be
# sure that "num" is the first argument and "divisor" is the second argument.
#
# Hint #1: You can use the modulus operator %% to find the remainder.
#   Ex: 7 %% 4 evaluates to 3. 
#
# Remember to set appropriate default values! Be sure to save this 
# script and type submit() in the console after you write the function.

remainder <- function(num, divisor = 2) {
  # Write your code here!
  # Remember: the last expression evaluated will be returned! 
  num %% divisor
}
Now back to console.

> submit()

| Sourcing your script...


| You are amazing!

|==========================                                                    |  33%

| Let's do some testing of the remainder function. Run remainder(5) and see what
| happens.

> remainder(5)
[1] 1

| You are amazing!

|============================                                                  |  35%

| Let's take a moment to examine what just happened. You provided one argument to the
| function, and R matched that argument to 'num' since 'num' is the first argument. The
| default value for 'divisor' is 2, so the function used the default value you
| provided.

...

|=============================                                                 |  38%

| Now let's test the remainder function by providing two arguments. Type: remainder(11,
| 5) and let's see what happens.

> remainder(11, 5)
[1] 1

| Perseverance, that's the answer.

|===============================                                               |  40%

| Once again, the arguments have been matched appropriately.

...

|================================                                              |  42%

| You can also explicitly specify arguments in a function. When you explicitly
| designate argument values by name, the ordering of the arguments becomes unimportant.
| You can try this out by typing: remainder(divisor = 11, num = 5).

> remainder(divisor = 11, num = 5)
[1] 5

| All that practice is paying off!

|==================================                                            |  44%

| As you can see, there is a significant difference between remainder(11, 5) and
| remainder(divisor = 11, num = 5)!

...

|====================================                                          |  46%

| R can also partially match arguments. Try typing remainder(4, div = 2) to see this
| feature in action.

> remainder(4, div = 2)
[1] 0

| All that practice is paying off!

|=====================================                                         |  48%

| A word of warning: in general you want to make your code as easy to understand as
| possible. Switching around the orders of arguments by specifying their names or only
| using partial argument names can be confusing, so use these features with caution!

...

|=======================================                                       |  50%

| With all of this talk about arguments, you may be wondering if there is a way you can
| see a function's arguments (besides looking at the documentation). Thankfully, you
| can use the args() function! Type: args(remainder) to examine the arguments for the
| remainder function.

> args(remainder)
function (num, divisor = 2) 
NULL

| You're the best!

|=========================================                                     |  52%

| You may not realize it but I just tricked you into doing something pretty
| interesting! args() is a function, remainder() is a function, yet remainder was an
| argument for args(). Yes it's true: you can pass functions as arguments! This is a
| very powerful concept. Let's write a script to see how it works.

...

|==========================================                                    |  54%

| Make sure to save your script before you type submit().
Now edit and save the R script evaluate.R.

# You can pass functions as arguments to other functions just like you can pass
# data to functions. Let's say you define the following functions:
#
# add_two_numbers <- function(num1, num2){
#    num1 + num2
# }
#
# multiply_two_numbers <- function(num1, num2){
#	num1 * num2
# }
#
# some_function <- function(func){
#    func(2, 4)
# }
#
# As you can see we use the argument name "func" like a function inside of 
# "some_function()." By passing functions as arguments 
# some_function(add_two_numbers) will evaluate to 6, while
# some_function(multiply_two_numbers) will evaluate to 8.
# 
# Finish the function definition below so that if a function is passed into the
# "func" argument and some data (like a vector) is passed into the dat argument
# the evaluate() function will return the result of dat being passed as an
# argument to func.
#
# Hints: This exercise is a little tricky so I'll provide a few example of how
# evaluate() should act:
#    1. evaluate(sum, c(2, 4, 6)) should evaluate to 12
#    2. evaluate(median, c(7, 40, 9)) should evaluate to 9
#    3. evaluate(floor, 11.1) should evaluate to 11

evaluate <- function(func, dat){
  # Write your code here!
  # Remember: the last expression evaluated will be returned! 
  func(dat)
}
Now back to console.

> submit()

| Sourcing your script...


| You got it right!

|============================================                                  |  56%

| Let's take your new evaluate() function for a spin! Use evaluate to find the standard
| deviation of the vector c(1.4, 3.6, 7.9, 8.8).

> evaluate(std, c(1.4, 3.6, 7.9, 8.8))
Error in evaluate(std, c(1.4, 3.6, 7.9, 8.8)) : object 'std' not found
> evaluate(sd, c(1.4, 3.6, 7.9, 8.8))
[1] 3.514138

| Excellent work!

|=============================================                                 |  58%

| The idea of passing functions as arguments to other functions is an important and
| fundamental concept in programming.

...

|===============================================                               |  60%

| You may be surprised to learn that you can pass a function as an argument without
| first defining the passed function. Functions that are not named are appropriately
| known as anonymous functions.

...

|=================================================                             |  62%

| Let's use the evaluate function to explore how anonymous functions work. For the
| first argument of the evaluate function we're going to write a tiny function that
| fits on one line. In the second argument we'll pass some data to the tiny anonymous
| function in the first argument.

...

 |==================================================                            |  65%

| Type the following command and then we'll discuss how it works:
| evaluate(function(x){x+1}, 6)

> evaluate(funcion(x){x+1}, 6)
Error: unexpected '{' in "evaluate(funcion(x){"
> evaluate
function(func, dat){
  # Write your code here!
  # Remember: the last expression evaluated will be returned! 
  func(dat)
}

| That's not the answer I was looking for, but try again. Or, type info() for more
| options.

| Just type the command evaluate(function(x){x+1}, 6)

> evaluate(function(x){x+1}, 6)
[1] 7

| Excellent job!

|====================================================                          |  67%

| The first argument is a tiny anonymous function that takes one argument `x` and
| returns `x+1`. We passed the number 6 into this function so the entire expression
| evaluates to 7.

...

|======================================================                        |  69%

| Try using evaluate() along with an anonymous function to return the first element of
| the vector c(8, 4, 0). Your anonymous function should only take one argument which
| should be a variable `x`.

> evaluate(function(x){x[1]}, c(8, 4, 0))
[1] 8

| You are quite good my friend!

|=======================================================                       |  71%

| Now try using evaluate() along with an anonymous function to return the last element
| of the vector c(8, 4, 0). Your anonymous function should only take one argument which
| should be a variable `x`.

> evaluate(function(x){x[-1]}, c(8, 4, 0))
[1] 4 0

| Nice try, but that's not exactly what I was hoping for. Try again. Or, type info()
| for more options.

| You may need to recall how to index vector elements. Remember that your anonymous
| function should only have one argument, and that argument should be named `x`. Using
| the length() function in your anonymous function may help you.

> evaluate(function(x){x[length(x)]}, c(8, 4, 0))
[1] 0

| That's a job well done!

|=========================================================                     |  73%

| For the rest of the course we're going to use the paste() function frequently. Type
| ?paste so we can take a look at the documentation for the paste function.

> ?paste

| You are amazing!

|==========================================================                    |  75%

| As you can see the first argument of paste() is `...` which is referred to as an
| ellipsis or simply dot-dot-dot. The ellipsis allows an indefinite number of arguments
| to be passed into a function. In the case of paste() any number of strings can be
| passed as arguments and paste() will return all of the strings combined into one
| string.

...

|============================================================                  |  77%

| Just to see how paste() works, type paste("Programming", "is", "fun!")

> paste("Programming", "is", "fun!")
[1] "Programming is fun!"

| That's the answer I was looking for.

|==============================================================                |  79%

| Time to write our own modified version of paste().

...

|===============================================================               |  81%

| Make sure to save your script before you type submit().
Now edit and save the R script telegram.R.

# The ellipses can be used to pass on arguments to other functions that are
# used within the function you're writing. Usually a function that has the
# ellipses as an argument has the ellipses as the last argument. The usage of
# such a function would look like:
#
# ellipses_func(arg1, arg2 = TRUE, ...)
#
# In the above example arg1 has no default value, so a value must be provided
# for arg1. arg2 has a default value, and other arguments can come after arg2
# depending on how they're defined in the ellipses_func() documentation.
# Interestingly the usage for the paste function is as follows:
#
# paste (..., sep = " ", collapse = NULL)
#
# Notice that the ellipses is the first argument, and all other arguments after
# the ellipses have default values. This is a strict rule in R programming: all
# arguments after an ellipses must have default values. Take a look at the
# simon_says function below:
#
# simon_says <- function(...){
#   paste("Simon says:", ...)
# }
#
# The simon_says function works just like the paste function, except the
# begining of every string is prepended by the string "Simon says:"
#
# Telegrams used to be peppered with the words START and STOP in order to
# demarcate the beginning and end of sentences. Write a function below called 
# telegram that formats sentences for telegrams.
# For example the expression `telegram("Good", "morning")` should evaluate to:
# "START Good morning STOP"

telegram <- function(...){
  paste("START", ..., "STOP", sep = " ")
}
Now back to console.

> submit()

| Sourcing your script...


| You are doing so well!

|=================================================================             |  83%

| Now let's test out your telegram function. Use your new telegram function passing in
| whatever arguments you wish!

> telegram(c("Hello", "world", ",", "how", "are", "we", "today", "?"))
[1] "START Hello STOP" "START world STOP" "START , STOP"     "START how STOP"  
[5] "START are STOP"   "START we STOP"    "START today STOP" "START ? STOP"    

| Nice work!

|===================================================================           |  85%

| Make sure to save your script before you type submit().

> play()

| Entering play mode. Experiment as you please, then type nxt() when you are ready to
| resume the lesson.

> telegram("Good", "morning")
[1] "START Good morning STOP"
> telegram(c("Good", "morning"))
[1] "START Good STOP"    "START morning STOP"
> nxt()

| Resuming lesson...


| Make sure to save your script before you type submit().
Now edit and save the R script mad_lib.R.

# Let's explore how to "unpack" arguments from an ellipses when you use the
# ellipses as an argument in a function. Below I have an example function that
# is supposed to add two explicitly named arguments called alpha and beta.
# 
# add_alpha_and_beta <- function(...){
#   # First we must capture the ellipsis inside of a list
#   # and then assign the list to a variable. Let's name this
#   # variable `args`.
#
#   args <- list(...)
#
#   # We're now going to assume that there are two named arguments within args
#   # with the names `alpha` and `beta.` We can extract named arguments from
#   # the args list by used the name of the argument and double brackets. The
#   # `args` variable is just a regular list after all!
#   
#   alpha <- args[["alpha"]]
#   beta  <- args[["beta"]]
#
#   # Then we return the sum of alpha and beta.
#
#   alpha + beta 
# }
#
# Have you ever played Mad Libs before? The function below will construct a
# sentence from parts of speech that you provide as arguments. We'll write most
# of the function, but you'll need to unpack the appropriate arguments from the
# ellipses.

mad_libs <- function(...){
  # Do your argument unpacking here!
  args <- list(...)
  
  place <- args[["place"]]
  adjective <- args[["adjective"]]
  noun <- args[["noun"]]
  
  # Don't modify any code below this comment.
  # Notice the variables you'll need to create in order for the code below to
  # be functional!
  paste("News from", place, "today where", adjective, "students took to the streets in protest of the new", noun, "being installed on campus.")
}
Now back to console.

> submit()

| Sourcing your script...


| That's a job well done!

|====================================================================          |  88%

| Time to use your mad_libs function. Make sure to name the place, adjective, and noun
| arguments in order for your function to work.

> mad_libs(place = London, adjustive = "beautiful", noun = "dog")
Error in mad_libs(place = London, adjustive = "beautiful", noun = "dog") : 
  object 'London' not found
> mad_libs(place = "London", adjustive = "beautiful", noun = "dog")
[1] "News from London today where  students took to the streets in protest of the new dog being installed on campus."

| Nice work!

|======================================================================        |  90%

| We're coming to the end of this lesson, but there's still one more idea you should be
| made aware of.

...

|========================================================================      |  92%

| You're familiar with adding, subtracting, multiplying, and dividing numbers in R. To
| do this you use the +, -, *, and / symbols. These symbols are called binary operators
| because they take two inputs, an input from the left and an input from the right.

...

|=========================================================================     |  94%

| In R you can define your own binary operators. In the next script I'll show you how.

...

|===========================================================================   |  96%

| Make sure to save your script before you type submit().

Now edit and save the R script bin_op.R.

# The syntax for creating new binary operators in R is unlike anything else in
# R, but it allows you to define a new syntax for your function. I would only
# recommend making your own binary operator if you plan on using it often!
#
# User-defined binary operators have the following syntax:
#      %[whatever]% 
# where [whatever] represents any valid variable name.
# 
# Let's say I wanted to define a binary operator that multiplied two numbers and
# then added one to the product. An implementation of that operator is below:
#
# "%mult_add_one%" <- function(left, right){ # Notice the quotation marks!
#   left * right + 1
# }
#
# I could then use this binary operator like `4 %mult_add_one% 5` which would
# evaluate to 21.
#
# Write your own binary operator below from absolute scratch! Your binary
# operator must be called %p% so that the expression:
#
#       "Good" %p% "job!"
#
# will evaluate to: "Good job!"

"%p%" <- function(left, right){ # Remember to add arguments!
  paste(left, right, sep = " ")
}
Now back to console.

> submit()

| Sourcing your script...


| Excellent job!

|============================================================================  |  98%

| You made your own binary operator! Let's test it out. Paste together the strings:
| 'I', 'love', 'R!' using your new binary operator.

> "I" %p% "love" % "R!"
Error: unexpected input in ""I" %p% "love" % "R!""
> "I" %p% "love" %p% "R!"
[1] "I love R!"

| You got it right!

|==============================================================================| 100%


#########################
10. lapply() and sapply()
#########################

|                                                                           |   0%
 
| In this lesson, you'll learn how to use lapply() and sapply(), the two most
| important members of R's *apply family of functions, also known as loop functions.
 
...
 
  |==                                                                         |   2%
 
| These powerful functions, along with their close relatives (vapply() and tapply(),
| among others) offer a concise and convenient means of implementing the
| Split-Apply-Combine strategy for data analysis.
 
...
 
  |===                                                                        |   4%
 
| Each of the *apply functions will SPLIT up some data into smaller pieces, APPLY a
| function to each piece, then COMBINE the results. A more detailed discussion of
| this strategy is found in Hadley Wickham's Journal of Statistical Software paper
| titled 'The Split-Apply-Combine Strategy for Data Analysis'.
 
...
 
  |====                                                                       |   6%
 
| Throughout this lesson, we'll use the Flags dataset from the UCI Machine Learning
| Repository. This dataset contains details of various nations and their flags. More
| information may be found here: http://archive.ics.uci.edu/ml/datasets/Flags
 
...
 
  |======                                                                     |   8%
 
| Let's jump right in so you can get a feel for how these special functions work!
 
...
 
  |========                                                                   |  10%
 
| I've stored the dataset in a variable called flags. Type head(flags) to preview
| the first six lines (i.e. the 'head') of the dataset.
 
> head(flags)
            name landmass zone area population language religion bars stripes
1    Afghanistan        5    1  648         16       10        2    0       3
2        Albania        3    1   29          3        6        6    0       0
3        Algeria        4    1 2388         20        8        2    2       0
4 American-Samoa        6    3    0          0        1        1    0       0
5        Andorra        3    1    0          0        6        0    3       0
6         Angola        4    2 1247          7       10        5    0       2
  colours red green blue gold white black orange mainhue circles crosses saltires
1       5   1     1    0    1     1     1      0   green       0       0        0
2       3   1     0    0    1     0     1      0     red       0       0        0
3       3   1     1    0    0     1     0      0   green       0       0        0
4       5   1     0    1    1     1     0      1    blue       0       0        0
5       3   1     0    1    1     0     0      0    gold       0       0        0
6       3   1     0    0    1     0     1      0     red       0       0        0
  quarters sunstars crescent triangle icon animate text topleft botright
1        0        1        0        0    1       0    0   black    green
2        0        1        0        0    0       1    0     red      red
3        0        1        1        0    0       0    0   green    white
4        0        0        0        1    1       1    0    blue      red
5        0        0        0        0    0       0    0    blue      red
6        0        1        0        0    1       0    0     red    black
 
| Great job!
 
  |=========                                                                  |  12%
 
| You may need to scroll up to see all of the output. Now, let's check out the
| dimensions of the dataset using dim(flags).
 
> dim(flags)
[1] 194  30
 
| You're the best!
 
  |===========                                                                |  14%
 
| This tells us that there are 194 rows, or observations, and 30 columns, or
| variables. Each observation is a country and each variable describes some
| characteristic of that country or its flag. To open a more complete description of
| the dataset in a separate text file, type viewinfo() when you are back at the
| prompt (>).
 
...
 
  |============                                                               |  16%
 
| As with any dataset, we'd like to know in what format the variables have been
| stored. In other words, what is the 'class' of each variable? What happens if we
| do class(flags)? Try it out.
 
> class(flags)
[1] "data.frame"
 
| Great job!
 
  |==============                                                             |  18%
 
| That just tells us that the entire dataset is stored as a 'data.frame', which
| doesn't answer our question. What we really need is to call the class() function
| on each individual column. While we could do this manually (i.e. one column at a
| time) it's much faster if we can automate the process. Sounds like a loop!
 
...
 
  |===============                                                            |  20%
 
| The lapply() function takes a list as input, applies a function to each element of
| the list, then returns a list of the same length as the original one. Since a data
| frame is really just a list of vectors (you can see this with as.list(flags)), we
| can use lapply() to apply the class() function to each column of the flags
| dataset. Let's see it in action!
 
...
 
  |================                                                           |  22%
 
| Type cls_list <- lapply(flags, class) to apply the class() function to each column
| of the flags dataset and store the result in a variable called cls_list. Note that
| you just supply the name of the function you want to apply (i.e. class), without
| the usual parentheses after it.
 
> cls_list <- lapply(flags, class)
 
| Great job!
 
  |==================                                                         |  24%
 
| Type cls_list to view the result.
 
> cls_list
$name
[1] "factor"
 
$landmass
[1] "integer"
 
$zone
[1] "integer"
 
$area
[1] "integer"
 
$population
[1] "integer"
 
$language
[1] "integer"
 
$religion
[1] "integer"
 
$bars
[1] "integer"
 
$stripes
[1] "integer"
 
$colours
[1] "integer"
 
$red
[1] "integer"
 
$green
[1] "integer"
 
$blue
[1] "integer"
 
$gold
[1] "integer"
 
$white
[1] "integer"
 
$black
[1] "integer"
 
$orange
[1] "integer"
 
$mainhue
[1] "factor"
 
$circles
[1] "integer"
 
$crosses
[1] "integer"
 
$saltires
[1] "integer"
 
$quarters
[1] "integer"
 
$sunstars
[1] "integer"
 
$crescent
[1] "integer"
 
$triangle
[1] "integer"
 
$icon
[1] "integer"
 
$animate
[1] "integer"
 
$text
[1] "integer"
 
$topleft
[1] "factor"
 
$botright
[1] "factor"
 
 
| You are amazing!
 
  |====================                                                       |  26%
 
| The 'l' in 'lapply' stands for 'list'. Type class(cls_list) to confirm that
| lapply() returned a list.
 
> class(cls_list)
[1] "list"
 
| You are amazing!
 
  |=====================                                                      |  28%
 
| As expected, we got a list of length 30 -- one element for each variable/column.
| The output would be considerably more compact if we could represent it as a vector
| instead of a list.
 
...
 
| You may remember from a previous lesson that lists are most helpful for storing
| multiple classes of data. In this case, since every element of the list returned
| by lapply() is a character vector of length one (i.e. "integer" and "vector"),
| cls_list can be simplified to a character vector. To do this manually, type
| as.character(cls_list).
 
> as.character(cls_list)
 [1] "factor"  "integer" "integer" "integer" "integer" "integer" "integer" "integer"
 [9] "integer" "integer" "integer" "integer" "integer" "integer" "integer" "integer"
[17] "integer" "factor"  "integer" "integer" "integer" "integer" "integer" "integer"
[25] "integer" "integer" "integer" "integer" "factor"  "factor" 
 
| That's a job well done!
 
  |========================                                                   |  32%
 
| sapply() allows you to automate this process by calling lapply() behind the
| scenes, but then attempting to simplify (hence the 's' in 'sapply') the result for
| you. Use sapply() the same way you used lapply() to get the class of each column
| of the flags dataset and store the result in cls_vect. If you need help, type
| ?sapply to bring up the documentation.
 
> cls_vect <- sapply(flags, class)
 
| You are really on a roll!
 
  |==========================                                                 |  34%
 
| Use class(cls_vect) to confirm that sapply() simplified the result to a character
| vector.
 
> class(cls_vect)
[1] "character"
 
| You are amazing!
 
  |===========================                                                |  36%
 
| In general, if the result is a list where every element is of length one, then
| sapply() returns a vector. If the result is a list where every element is a vector
| of the same length (> 1), sapply() returns a matrix. If sapply() can't figure
| things out, then it just returns a list, no different from what lapply() would
| give you.
 
...
 
  |============================                                               |  38%
 
| Let's practice using lapply() and sapply() some more!
 
...
 
  |==============================                                             |  40%
 
| Columns 11 through 17 of our dataset are indicator variables, each representing a
| different color. The value of the indicator variable is 1 if the color is present
| in a country's flag and 0 otherwise.
 
...
 
  |================================                                           |  42%
 
| Therefore, if we want to know the total number of countries (in our dataset) with,
| for example, the color orange on their flag, we can just add up all of the 1s and
| 0s in the 'orange' column. Try sum(flags$orange) to see this.
 
> sum(flags$orange)
[1] 26
 
| That's the answer I was looking for.
 
  |=================================                                          |  44%
 
| Now we want to repeat this operation for each of the colors recorded in the
| dataset.
 
...
 
  |==================================                                         |  46%
 
| First, use flag_colors <- flags[, 11:17] to extract the columns containing the
| color data and store them in a new data frame called flag_colors. (Note the comma
| before 11:17. This subsetting command tells R that we want all rows, but only
| columns 11 through 17.)
 
> flag_colors <- flags[,11:17]
 
| Excellent work!
 
  |====================================                                       |  48%
 
| Use the head() function to look at the first 6 lines of flag_colors.
 
> head(flag_colors)
  red green blue gold white black orange
1   1     1    0    1     1     1      0
2   1     0    0    1     0     1      0
3   1     1    0    0     1     0      0
4   1     0    1    1     1     0      1
5   1     0    1    1     0     0      0
6   1     0    0    1     0     1      0
 
| Great job!
 
  |======================================                                     |  50%
 
| To get a list containing the sum of each column of flag_colors, call the lapply()
| function with two arguments. The first argument is the object over which we are
| looping (i.e. flag_colors) and the second argument is the name of the function we
| wish to apply to each column (i.e. sum). Remember that the second argument is just
| the name of the function with no parentheses, etc.
 
> lapply(flag_colors, sum)
$red
[1] 153
 
$green
[1] 91
 
$blue
[1] 99
 
$gold
[1] 91
 
$white
[1] 146
 
$black
[1] 52
 
$orange
[1] 26
 
 
| Keep up the great work!
 
  |=======================================                                    |  52%
 
| This tells us that of the 194 flags in our dataset, 153 contain the color red, 91
| contain green, 99 contain blue, and so on.
 
...
 
  |========================================                                   |  54%
 
| The result is a list, since lapply() always returns a list. Each element of this
| list is of length one, so the result can be simplified to a vector by calling
| sapply() instead of lapply(). Try it now.
 
> sapply(flag_colors, sum)
   red  green   blue   gold  white  black orange 
   153     91     99     91    146     52     26 
 
| You are doing so well!
 
  |==========================================                                 |  56%
 
| Perhaps it's more informative to find the proportion of flags (out of 194)
| containing each color. Since each column is just a bunch of 1s and 0s, the
| arithmetic mean of each column will give us the proportion of 1s. (If it's not
| clear why, think of a simpler situation where you have three 1s and two 0s -- (1 +
| 1 + 1 + 0 + 0)/5 = 3/5 = 0.6).
 
...
 
  |============================================                               |  58%
 
| Use sapply() to apply the mean() function to each column of flag_colors. Remember
| that the second argument to sapply() should just specify the name of the function
| (i.e. mean) that you want to apply.
 
> sapply(flag_colors, mean)
      red     green      blue      gold     white     black    orange 
0.7886598 0.4690722 0.5103093 0.4690722 0.7525773 0.2680412 0.1340206 
 
| That's the answer I was looking for.
 
  |=============================================                              |  60%
 
| In the examples we've looked at so far, sapply() has been able to simplify the
| result to vector. That's because each element of the list returned by lapply() was
| a vector of length one. Recall that sapply() instead returns a matrix when each
| element of the list returned by lapply() is a vector of the same length (> 1).
 
...
 
  |==============================================                             |  62%
 
| To illustrate this, let's extract columns 19 through 23 from the flags dataset and
| store the result in a new data frame called flag_shapes. flag_shapes <- flags[,
| 19:23] will do it.
 
> flag_shapes <- flags[,19:23]
 
| Keep up the great work!
 
  |================================================                           |  64%
 
| Each of these columns (i.e. variables) represents the number of times a particular
| shape or design appears on a country's flag. We are interested in the minimum and
| maximum number of times each shape or design appears.
 
...
 
  |==================================================                         |  66%
 
| The range() function returns the minimum and maximum of its first argument, which
| should be a numeric vector. Use lapply() to apply the range function to each
| column of flag_shapes. Don't worry about storing the result in a new variable. By
| now, we know that lapply() always returns a list.
 
> lapply(flag_shapes, range)
$circles
[1] 0 4
 
$crosses
[1] 0 2
 
$saltires
[1] 0 1
 
$quarters
[1] 0 4
 
$sunstars
[1]  0 50
 
 
| You're the best!
 
  |===================================================                        |  68%
 
| Do the same operation, but using sapply() and store the result in a variable
| called shape_mat.
 
> shape_mat <- sapply(flag_shapes, range)
 
| You are doing so well!
 
  |=====================================================                      |  70%
 
| View the contents of shape_mat.
 
> 
> shape_mat
     circles crosses saltires quarters sunstars
[1,]       0       0        0        0        0
[2,]       4       2        1        4       50
 
| You are quite good my friend!
 
  |======================================================                     |  72%
 
| Each column of shape_mat gives the minimum (row 1) and maximum (row 2) number of
| times its respective shape appears in different flags.
 
...
 
  |========================================================                   |  74%
 
| Use the class() function to confirm that shape_mat is a matrix.
 
> class(shape_mat)
[1] "matrix"
 
| You nailed it! Good job!
 
  |=========================================================                  |  76%
 
| As we've seen, sapply() always attempts to simplify the result given by lapply().
| It has been successful in doing so for each of the examples we've looked at so
| far. Let's look at an example where sapply() can't figure out how to simplify the
| result and thus returns a list, no different from lapply().
 
...
 
  |==========================================================                 |  78%
 
| When given a vector, the unique() function returns a vector with all duplicate
| elements removed. In other words, unique() returns a vector of only the 'unique'
| elements. To see how it works, try unique(c(3, 4, 5, 5, 5, 6, 6)).
 
> unique(c(3, 4, 5, 5, 5, 6, 6))
[1] 3 4 5 6
 
| Excellent job!
 
  |============================================================               |  80%
 
| We want to know the unique values for each variable in the flags dataset. To
| accomplish this, use lapply() to apply the unique() function to each column in the
| flags dataset, storing the result in a variable called unique_vals.
 
> unique_vals <- lapply(flags, unique)
 
| That's correct!
 
  |==============================================================             |  82%
 
| Print the value of unique_vals to the console.
 
> unique_vals
$name
  [1] Afghanistan              Albania                  Algeria                 
  [4] American-Samoa           Andorra                  Angola                  
  [7] Anguilla                 Antigua-Barbuda          Argentina               
 [10] Argentine                Australia                Austria                 
 [13] Bahamas                  Bahrain                  Bangladesh              
 [16] Barbados                 Belgium                  Belize                  
 [19] Benin                    Bermuda                  Bhutan                  
 [22] Bolivia                  Botswana                 Brazil                  
 [25] British-Virgin-Isles     Brunei                   Bulgaria                
 [28] Burkina                  Burma                    Burundi                 
 [31] Cameroon                 Canada                   Cape-Verde-Islands      
 [34] Cayman-Islands           Central-African-Republic Chad                    
 [37] Chile                    China                    Colombia                
 [40] Comorro-Islands          Congo                    Cook-Islands            
 [43] Costa-Rica               Cuba                     Cyprus                  
 [46] Czechoslovakia           Denmark                  Djibouti                
 [49] Dominica                 Dominican-Republic       Ecuador                 
 [52] Egypt                    El-Salvador              Equatorial-Guinea       
 [55] Ethiopia                 Faeroes                  Falklands-Malvinas      
 [58] Fiji                     Finland                  France                  
 [61] French-Guiana            French-Polynesia         Gabon                   
 [64] Gambia                   Germany-DDR              Germany-FRG             
 [67] Ghana                    Gibraltar                Greece                  
 [70] Greenland                Grenada                  Guam                    
 [73] Guatemala                Guinea                   Guinea-Bissau           
 [76] Guyana                   Haiti                    Honduras                
 [79] Hong-Kong                Hungary                  Iceland                 
 [82] India                    Indonesia                Iran                    
 [85] Iraq                     Ireland                  Israel                  
 [88] Italy                    Ivory-Coast              Jamaica                 
 [91] Japan                    Jordan                   Kampuchea               
 [94] Kenya                    Kiribati                 Kuwait                  
 [97] Laos                     Lebanon                  Lesotho                 
[100] Liberia                  Libya                    Liechtenstein           
[103] Luxembourg               Malagasy                 Malawi                  
[106] Malaysia                 Maldive-Islands          Mali                    
[109] Malta                    Marianas                 Mauritania              
[112] Mauritius                Mexico                   Micronesia              
[115] Monaco                   Mongolia                 Montserrat              
[118] Morocco                  Mozambique               Nauru                   
[121] Nepal                    Netherlands              Netherlands-Antilles    
[124] New-Zealand              Nicaragua                Niger                   
[127] Nigeria                  Niue                     North-Korea             
[130] North-Yemen              Norway                   Oman                    
[133] Pakistan                 Panama                   Papua-New-Guinea        
[136] Parguay                  Peru                     Philippines             
[139] Poland                   Portugal                 Puerto-Rico             
[142] Qatar                    Romania                  Rwanda                  
[145] San-Marino               Sao-Tome                 Saudi-Arabia            
[148] Senegal                  Seychelles               Sierra-Leone            
[151] Singapore                Soloman-Islands          Somalia                 
[154] South-Africa             South-Korea              South-Yemen             
[157] Spain                    Sri-Lanka                St-Helena               
[160] St-Kitts-Nevis           St-Lucia                 St-Vincent              
[163] Sudan                    Surinam                  Swaziland               
[166] Sweden                   Switzerland              Syria                   
[169] Taiwan                   Tanzania                 Thailand                
[172] Togo                     Tonga                    Trinidad-Tobago         
[175] Tunisia                  Turkey                   Turks-Cocos-Islands     
[178] Tuvalu                   UAE                      Uganda                  
[181] UK                       Uruguay                  US-Virgin-Isles         
[184] USA                      USSR                     Vanuatu                 
[187] Vatican-City             Venezuela                Vietnam                 
[190] Western-Samoa            Yugoslavia               Zaire                   
[193] Zambia                   Zimbabwe                
194 Levels: Afghanistan Albania Algeria American-Samoa Andorra Angola ... Zimbabwe
 
$landmass
[1] 5 3 4 6 1 2
 
$zone
[1] 1 3 2 4
 
$area
  [1]   648    29  2388     0  1247  2777  7690    84    19     1   143    31    23
 [14]   113    47  1099   600  8512     6   111   274   678    28   474  9976     4
 [27]   623  1284   757  9561  1139     2   342    51   115     9   128    43    22
 [40]    49   284  1001    21  1222    12    18   337   547    91   268    10   108
 [53]   249   239   132  2176   109   246    36   215   112    93   103  3268  1904
 [66]  1648   435    70   301   323    11   372    98   181   583   236    30  1760
 [79]     3   587   118   333  1240  1031  1973  1566   447   783   140    41  1267
 [92]   925   121   195   324   212   804    76   463   407  1285   300   313    92
[105]   237    26  2150   196    72   637  1221    99   288   505    66  2506    63
[118]    17   450   185   945   514    57     5   164   781   245   178  9363 22402
[131]    15   912   256   905   753   391
 
$population
 [1]   16    3   20    0    7   28   15    8   90   10    1    6  119    9   35    4
[17]   24    2   11 1008    5   47   31   54   17   61   14  684  157   39   57  118
[33]   13   77   12   56   18   84   48   36   22   29   38   49   45  231  274   60
 
$language
 [1] 10  6  8  1  2  4  3  5  7  9
 
$religion
[1] 2 6 1 0 5 3 4 7
 
$bars
[1] 0 2 3 1 5
 
$stripes
 [1]  3  0  2  1  5  9 11 14  4  6 13  7
 
$colours
[1] 5 3 2 8 6 4 7 1
 
$red
[1] 1 0
 
$green
[1] 1 0
 
$blue
[1] 0 1
 
$gold
[1] 1 0
 
$white
[1] 1 0
 
$black
[1] 1 0
 
$orange
[1] 0 1
 
$mainhue
[1] green  red    blue   gold   white  orange black  brown 
Levels: black blue brown gold green orange red white
 
$circles
[1] 0 1 4 2
 
$crosses
[1] 0 1 2
 
$saltires
[1] 0 1
 
$quarters
[1] 0 1 4
 
$sunstars
 [1]  1  0  6 22 14  3  4  5 15 10  7  2  9 50
 
$crescent
[1] 0 1
 
$triangle
[1] 0 1
 
$icon
[1] 1 0
 
$animate
[1] 0 1
 
$text
[1] 0 1
 
$topleft
[1] black  red    green  blue   white  orange gold  
Levels: black blue gold green orange red white
 
$botright
[1] green  red    white  black  blue   gold   orange brown 
Levels: black blue brown gold green orange red white
 
 
| Keep working like that and you'll get there!
 
  |===============================================================            |  84%
 
| Since unique_vals is a list, you can use what you've learned to determine the
| length of each element of unique_vals (i.e. the number of unique values for each
| variable). Simplify the result, if possible. Hint: Apply the length() function to
| each element of unique_vals.
 
> lapply(unique_vals, length)
$name
[1] 194
 
$landmass
[1] 6
 
$zone
[1] 4
 
$area
[1] 136
 
$population
[1] 48
 
$language
[1] 10
 
$religion
[1] 8
 
$bars
[1] 5
 
$stripes
[1] 12
 
$colours
[1] 8
 
$red
[1] 2
 
$green
[1] 2
 
$blue
[1] 2
 
$gold
[1] 2
 
$white
[1] 2
 
$black
[1] 2
 
$orange
[1] 2
 
$mainhue
[1] 8
 
$circles
[1] 4
 
$crosses
[1] 3
 
$saltires
[1] 2
 
$quarters
[1] 3
 
$sunstars
[1] 14
 
$crescent
[1] 2
 
$triangle
[1] 2
 
$icon
[1] 2
 
$animate
[1] 2
 
$text
[1] 2
 
$topleft
[1] 7
 
$botright
[1] 8
 
 
| Nice try, but that's not exactly what I was hoping for. Try again. Or, type info()
| for more options.
 
| Apply the length() function to each element of the unique_vals list using
| sapply(). Remember, no parentheses after the name of the function you are applying
| (i.e. length).
 
> sapply(unique_vals, length)
      name   landmass       zone       area population   language   religion 
       194          6          4        136         48         10          8 
      bars    stripes    colours        red      green       blue       gold 
         5         12          8          2          2          2          2 
     white      black     orange    mainhue    circles    crosses   saltires 
         2          2          2          8          4          3          2 
  quarters   sunstars   crescent   triangle       icon    animate       text 
         3         14          2          2          2          2          2 
   topleft   botright 
         7          8 
 
| That's the answer I was looking for.
 
  |================================================================           |  86%
 
| The fact that the elements of the unique_vals list are all vectors of *different*
| length poses a problem for sapply(), since there's no obvious way of simplifying
| the result.
 
...
 
  |==================================================================         |  88%
 
| Use sapply() to apply the unique() function to each column of the flags dataset to
| see that you get the same unsimplified list that you got from lapply().
 
> sapply(flags,unique)
$name
  [1] Afghanistan              Albania                  Algeria                 
  [4] American-Samoa           Andorra                  Angola                  
  [7] Anguilla                 Antigua-Barbuda          Argentina               
 [10] Argentine                Australia                Austria                 
 [13] Bahamas                  Bahrain                  Bangladesh              
 [16] Barbados                 Belgium                  Belize                  
 [19] Benin                    Bermuda                  Bhutan                  
 [22] Bolivia                  Botswana                 Brazil                  
 [25] British-Virgin-Isles     Brunei                   Bulgaria                
 [28] Burkina                  Burma                    Burundi                 
 [31] Cameroon                 Canada                   Cape-Verde-Islands      
 [34] Cayman-Islands           Central-African-Republic Chad                    
 [37] Chile                    China                    Colombia                
 [40] Comorro-Islands          Congo                    Cook-Islands            
 [43] Costa-Rica               Cuba                     Cyprus                  
 [46] Czechoslovakia           Denmark                  Djibouti                
 [49] Dominica                 Dominican-Republic       Ecuador                 
 [52] Egypt                    El-Salvador              Equatorial-Guinea       
 [55] Ethiopia                 Faeroes                  Falklands-Malvinas      
 [58] Fiji                     Finland                  France                  
 [61] French-Guiana            French-Polynesia         Gabon                   
 [64] Gambia                   Germany-DDR              Germany-FRG             
 [67] Ghana                    Gibraltar                Greece                  
 [70] Greenland                Grenada                  Guam                    
 [73] Guatemala                Guinea                   Guinea-Bissau           
 [76] Guyana                   Haiti                    Honduras                
 [79] Hong-Kong                Hungary                  Iceland                 
 [82] India                    Indonesia                Iran                    
 [85] Iraq                     Ireland                  Israel                  
 [88] Italy                    Ivory-Coast              Jamaica                 
 [91] Japan                    Jordan                   Kampuchea               
 [94] Kenya                    Kiribati                 Kuwait                  
 [97] Laos                     Lebanon                  Lesotho                 
[100] Liberia                  Libya                    Liechtenstein           
[103] Luxembourg               Malagasy                 Malawi                  
[106] Malaysia                 Maldive-Islands          Mali                    
[109] Malta                    Marianas                 Mauritania              
[112] Mauritius                Mexico                   Micronesia              
[115] Monaco                   Mongolia                 Montserrat              
[118] Morocco                  Mozambique               Nauru                   
[121] Nepal                    Netherlands              Netherlands-Antilles    
[124] New-Zealand              Nicaragua                Niger                   
[127] Nigeria                  Niue                     North-Korea             
[130] North-Yemen              Norway                   Oman                    
[133] Pakistan                 Panama                   Papua-New-Guinea        
[136] Parguay                  Peru                     Philippines             
[139] Poland                   Portugal                 Puerto-Rico             
[142] Qatar                    Romania                  Rwanda                  
[145] San-Marino               Sao-Tome                 Saudi-Arabia            
[148] Senegal                  Seychelles               Sierra-Leone            
[151] Singapore                Soloman-Islands          Somalia                 
[154] South-Africa             South-Korea              South-Yemen             
[157] Spain                    Sri-Lanka                St-Helena               
[160] St-Kitts-Nevis           St-Lucia                 St-Vincent              
[163] Sudan                    Surinam                  Swaziland               
[166] Sweden                   Switzerland              Syria                   
[169] Taiwan                   Tanzania                 Thailand                
[172] Togo                     Tonga                    Trinidad-Tobago         
[175] Tunisia                  Turkey                   Turks-Cocos-Islands     
[178] Tuvalu                   UAE                      Uganda                  
[181] UK                       Uruguay                  US-Virgin-Isles         
[184] USA                      USSR                     Vanuatu                 
[187] Vatican-City             Venezuela                Vietnam                 
[190] Western-Samoa            Yugoslavia               Zaire                   
[193] Zambia                   Zimbabwe                
194 Levels: Afghanistan Albania Algeria American-Samoa Andorra Angola ... Zimbabwe
 
$landmass
[1] 5 3 4 6 1 2
 
$zone
[1] 1 3 2 4
 
$area
  [1]   648    29  2388     0  1247  2777  7690    84    19     1   143    31    23
 [14]   113    47  1099   600  8512     6   111   274   678    28   474  9976     4
 [27]   623  1284   757  9561  1139     2   342    51   115     9   128    43    22
 [40]    49   284  1001    21  1222    12    18   337   547    91   268    10   108
 [53]   249   239   132  2176   109   246    36   215   112    93   103  3268  1904
 [66]  1648   435    70   301   323    11   372    98   181   583   236    30  1760
 [79]     3   587   118   333  1240  1031  1973  1566   447   783   140    41  1267
 [92]   925   121   195   324   212   804    76   463   407  1285   300   313    92
[105]   237    26  2150   196    72   637  1221    99   288   505    66  2506    63
[118]    17   450   185   945   514    57     5   164   781   245   178  9363 22402
[131]    15   912   256   905   753   391
 
$population
 [1]   16    3   20    0    7   28   15    8   90   10    1    6  119    9   35    4
[17]   24    2   11 1008    5   47   31   54   17   61   14  684  157   39   57  118
[33]   13   77   12   56   18   84   48   36   22   29   38   49   45  231  274   60
 
$language
 [1] 10  6  8  1  2  4  3  5  7  9
 
$religion
[1] 2 6 1 0 5 3 4 7
 
$bars
[1] 0 2 3 1 5
 
$stripes
 [1]  3  0  2  1  5  9 11 14  4  6 13  7
 
$colours
[1] 5 3 2 8 6 4 7 1
 
$red
[1] 1 0
 
$green
[1] 1 0
 
$blue
[1] 0 1
 
$gold
[1] 1 0
 
$white
[1] 1 0
 
$black
[1] 1 0
 
$orange
[1] 0 1
 
$mainhue
[1] green  red    blue   gold   white  orange black  brown 
Levels: black blue brown gold green orange red white
 
$circles
[1] 0 1 4 2
 
$crosses
[1] 0 1 2
 
$saltires
[1] 0 1
 
$quarters
[1] 0 1 4
 
$sunstars
 [1]  1  0  6 22 14  3  4  5 15 10  7  2  9 50
 
$crescent
[1] 0 1
 
$triangle
[1] 0 1
 
$icon
[1] 1 0
 
$animate
[1] 0 1
 
$text
[1] 0 1
 
$topleft
[1] black  red    green  blue   white  orange gold  
Levels: black blue gold green orange red white
 
$botright
[1] green  red    white  black  blue   gold   orange brown 
Levels: black blue brown gold green orange red white
 
 
| You are amazing!
 
  |====================================================================       |  90%
 
| Occasionally, you may need to apply a function that is not yet defined, thus
| requiring you to write your own. Writing functions in R is beyond the scope of
| this lesson, but let's look at a quick example of how you might do so in the
| context of loop functions.
 
...
 
  |=====================================================================      |  92%
 
| Pretend you are interested in only the second item from each element of the
| unique_vals list that you just created. Since each element of the unique_vals list
| is a vector and we're not aware of any built-in function in R that returns the
| second element of a vector, we will construct our own function.
 
...
 
  |======================================================================     |  94%
 
| lapply(unique_vals, function(elem) elem[2]) will return a list containing the
| second item from each element of the unique_vals list. Note that our function
| takes one argument, elem, which is just a 'dummy variable' that takes on the value
| of each element of unique_vals, in turn.
 
> lapply(unique_vals, function(elem) elem[2])
$name
[1] Albania
194 Levels: Afghanistan Albania Algeria American-Samoa Andorra Angola ... Zimbabwe
 
$landmass
[1] 3
 
$zone
[1] 3
 
$area
[1] 29
 
$population
[1] 3
 
$language
[1] 6
 
$religion
[1] 6
 
$bars
[1] 2
 
$stripes
[1] 0
 
$colours
[1] 3
 
$red
[1] 0
 
$green
[1] 0
 
$blue
[1] 1
 
$gold
[1] 0
 
$white
[1] 0
 
$black
[1] 0
 
$orange
[1] 1
 
$mainhue
[1] red
Levels: black blue brown gold green orange red white
 
$circles
[1] 1
 
$crosses
[1] 1
 
$saltires
[1] 1
 
$quarters
[1] 1
 
$sunstars
[1] 0
 
$crescent
[1] 1
 
$triangle
[1] 1
 
$icon
[1] 0
 
$animate
[1] 1
 
$text
[1] 1
 
$topleft
[1] red
Levels: black blue gold green orange red white
 
$botright
[1] red
Levels: black blue brown gold green orange red white
 
 
| Nice work!
 
  |========================================================================   |  96%
 
| The only difference between previous examples and this one is that we are defining
| and using our own function right in the call to lapply(). Our function has no name
| and disappears as soon as lapply() is done using it. So-called 'anonymous
| functions' can be very useful when one of R's built-in functions isn't an option.
 
...
 
  |========================================================================== |  98%
 
| In this lesson, you learned how to use the powerful lapply() and sapply()
| functions to apply an operation over the elements of a list. In the next lesson,
| we'll take a look at some close relatives of lapply() and sapply().
 
...
 
  |===========================================================================| 100%
